schema {
  query: Query
  mutation: Mutation
}
"Color represented as 6 character RGB hexcode."
scalar HexColorCode
"A date that specify a point in time in ISO8601, e.g. 2020-06-04"
scalar ISO8601Date
"A (instant) date time with up to nanosecond precision, for example: 2016-06-10T21:42:24.760738998Z"
scalar ISO8601DateTime
type AbsenceSlice {
  date: ISO8601Date!
  hours: Float!
  days: Float!
  fte: Float!
}
type ActualFinancialEvent {
  id: ID!
  bookingDate: ISO8601Date!
  amount: Float!
  type: FinancialEventType!
  category: FinanceCategory
  description: String
}
type ActualFinancialEventDeleteUserErrors {
  message: String!
  type: ActualFinancialEventDeleteUserErrorsType!
  path: [String!]!
}
type ActualFinancialEventEditPayload {
  actualFinancialEvent: ActualFinancialEvent
  userErrors: [ActualFinancialEventEditUserErrors!]!
}
type ActualFinancialEventEditUserErrors {
  message: String!
  type: ActualFinancialEventEditUserErrorsType!
  path: [String!]!
}
type ActualFinancialEventsCreateOrUpdatePayload {
  actualFinancialEvents: [ActualFinancialEvent!] @deprecated(reason: "use created and deleted instead")
  createdActualFinancialEvents: [ActualFinancialEvent!]
  deletedActualFinancialEvents: [ActualFinancialEvent!]
  userErrors: [ActualFinancialEventUserErrors!]!
}
type ActualFinancialEventsDeletePayload {
  userErrors: [ActualFinancialEventDeleteUserErrors!]!
}
type ActualFinancialEventUserErrors {
  message: String!
  type: ActualFinancialEventErrorType!
  path: [String!]!
}
type ActualsByEntity {
  project: Project!
  actualsReferenceEntity: ActualsReferenceEntity
  actuals: [ActualsEntry!]!
}
type ActualsCostInfo {
  costType: CostType!
  costPerHour: Float
}
type ActualsCreateOrUpdatePayload {
  actual: ActualsByEntity
  userErrors: [ActualsCreateOrUpdateUserError!]!
}
type ActualsCreateOrUpdateUserError {
  message: String!
  type: ActualsCreateOrUpdateErrorType!
  path: [String!]!
}
type ActualsEntry {
  id: ID!
  bookingDate: ISO8601Date!
  amount: Float!
  unit: AmountUnit!
  "Missing ACCESS_FINANCIAL_DATA permission returns an error"
  costType: CostType
  "Missing ACCESS_FINANCIAL_DATA permission returns an error"
  costPerHour: Float
}
type ActualTimeWorkedByEntity {
  id: ID!
  actualTimeWorkedReferenceEntity: ActualsReferenceEntity
  totalHours: Float!
  "Missing ACCESS_FINANCIAL_DATA permission returns an error"
  totalCost: Float
  actuals: [ActualsEntry!]!
  """
  Returns slices for the given period. The time period is aggregated into slices as defined by the given aggregation mode.
  The slices are splited by cost type, which means that a slice is returned for each cost type.
  Only slices are returned where hours > 0.
  """
  slices(aggregation: ActualSliceAggregationMode!, period: ActualSlicePeriodInput): [ActualTimeWorkedSlice!]!
}
type ActualTimeWorkedByEntityConnection {
  edges: [ActualTimeWorkedByEntityEdge!]!
  pageInfo: ForwardPageInfo!
}
type ActualTimeWorkedByEntityEdge {
  cursor: String!
  node: ActualTimeWorkedByEntity!
}
type ActualTimeWorkedDeleteAllPayload {
  userErrors: [ActualTimeWorkedDeleteAllUserError!]!
}
type ActualTimeWorkedDeleteAllUserError {
  message: String!
  type: ActualTimeWorkedDeleteAllErrorType!
  path: [String!]!
}
type ActualTimeWorkedDeletePayload {
  actualTimeWorked: ProjectActualTimeWorked
  userErrors: [ActualTimeWorkedDeleteUserError!]!
}
type ActualTimeWorkedDeleteUserError {
  message: String!
  type: ActualTimeWorkedDeleteErrorType!
  path: [String!]!
}
type ActualTimeWorkedSlice {
  aggregationMode: ActualSliceAggregationMode!
  "Slice period start date"
  date: ISO8601Date!
  hours: Float!
  "Missing ACCESS_FINANCIAL_DATA permission returns an error"
  cost: Float
  "Missing ACCESS_FINANCIAL_DATA permission returns an error"
  costType: CostType
}
type AggregatedAllocationSlice {
  date: ISO8601Date!
  fte: Float!
  hours: Float!
  days: Float!
}
type AllocationConnection {
  edges: [AllocationEdge!]!
  pageInfo: PageInfo!
}
type AllocationEdge {
  cursor: String!
  node: Allocation!
}
type AllocationKPIs {
  remainingAllocationsFromToday: Float!
  plannedAllocationsBetweenLastBookingDateAndToday: Float
}
type AllocationSegment {
  start: ISO8601Date!
  end: ISO8601Date!
  valueInHours: Float!
  valueInDays: Float!
  valueInFTE: Float!
}
type AllocationSlice {
  date: ISO8601Date!
  fte: Float!
  hours: Float!
  days: Float!
}
type ApolloAlpaca {
  baseUrlExternal: String!
}
type AuthenticationSettings {
  loginNotice: String
}
type Authenticorn {
  baseUrlExternal: String!
}
type BooleanField {
  booleanFieldDefinition: BooleanFieldDefinition!
  booleanValue: Boolean!
}
type BooleanFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type BusinessGoal {
  id: ID!
  externalId: String!
  name: String!
  color: HexColorCode!
}
type BusinessGoalCreatePayload {
  userError: BusinessGoalCreateUserError
  businessGoal: BusinessGoal
}
type BusinessGoalCreateUserError {
  message: String!
  type: BusinessGoalCreateErrorType!
  path: [String!]!
}
type BusinessGoalEmpty {
  _: Boolean
}
type BusinessGoalReferenceField {
  businessGoalReferenceFieldDefinition: BusinessGoalReferenceFieldDefinition!
  businessGoalReferenceValue: BusinessGoal
}
type BusinessGoalReferenceFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type Calendar {
  id: ID!
  name: String!
  pathFromRoot: [Calendar!]!
  workTimeByDayOfWeek: [CalendarWorkTimeByDayOfWeek!]!
  workTimeExceptions(filter: CalendarWorkTimeExceptionFilterInput): [CalendarWorkTimeException!]!
}
type CalendarCreatePayload {
  userError: CalendarCreateUserError
  calendar: Calendar
}
type CalendarCreateUserError {
  message: String!
  type: CalendarCreateErrorType!
  path: [String!]!
}
type CalendarDeletePayload {
  userError: CalendarDeleteUserError
}
type CalendarDeleteUserError {
  message: String!
  type: CalendarDeleteErrorType!
  path: [String!]!
}
type CalendarDeviation {
  start: ISO8601Date
  end: ISO8601Date
  relativeCapacity: Float!
}
type CalendarUpdatePayload {
  userError: CalendarUpdateUserError
  calendar: Calendar
}
type CalendarUpdateUserError {
  message: String!
  type: CalendarUpdateErrorType!
  path: [String!]!
}
type CalendarWorkTimeByDayOfWeek {
  dayOfWeek: DayOfWeek!
  workTimeInHours: Float!
}
type CalendarWorkTimeException {
  date: ISO8601Date!
  workTimeInHours: Float!
  description: String!
  sourceCalendar: Calendar!
}
type CapacitySlice {
  date: ISO8601Date!
  fte: Float!
  hours: Float!
  days: Float!
}
type ChangeLogBooleanFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: BooleanFieldDefinition
  changedFrom: Boolean
  changedTo: Boolean
}
type ChangeLogBusinessGoalReferenceFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: BusinessGoalReferenceFieldDefinition
  "Can be null, when the business goal was deleted. (resolved via Federation)"
  businessGoalChangedFrom: BusinessGoalOptional
  "Can be null, when the business goal was deleted. (resolved via Federation)"
  businessGoalChangedTo: BusinessGoalOptional
}
type ChangeLogCostTypeFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: CostTypeFieldDefinition
  changedFrom: CostType
  changedTo: CostType
}
type ChangeLogDateFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: DateFieldDefinition
  changedFrom: ISO8601Date
  changedTo: ISO8601Date
}
type ChangeLogDecimalFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: DecimalFieldDefinition
  changedFrom: Float
  changedTo: Float
}
type ChangeLogIntegerFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: IntegerFieldDefinition
  "Defined as a float value to support very high numbers"
  changedFrom: Float
  "Defined as a float value to support very high numbers"
  changedTo: Float
}
type ChangeLogLookupFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: LookupFieldDefinition
  "Can be null, when the lookup value was deleted. (resolved via Federation)"
  lookupFieldValueChangedFrom: LookupFieldValueOptional
  "Can be null, when the lookup value was deleted. (resolved via Federation)"
  lookupFieldValueChangedTo: LookupFieldValueOptional
}
type ChangeLogMilestoneNameChange {
  "Can be null, when the milestone was deleted. (resolved via Federation)"
  milestone: Milestone
  changedFrom: String
  changedTo: String
}
type ChangeLogMilestonePhaseChange {
  "Can be null, when the milestone was deleted. (resolved via Federation)"
  milestone: Milestone
  projectPhaseChangedFrom: ProjectPhaseOptional
  projectPhaseChangedTo: ProjectPhaseOptional
}
type ChangeLogMilestoneScheduleAfterProjectScheduleFixed {
  "Can be null, when the milestoneSchedule was deleted. (resolved via Federation)"
  milestoneSchedule: MilestoneSchedule
  dateChangedFrom: ISO8601Date!
  dateChangedTo: ISO8601Date!
}
type ChangeLogMilestoneScheduleCreated {
  "Can be null, when the milestoneSchedule was deleted. (resolved via Federation)"
  milestoneSchedule: MilestoneSchedule
  date: ISO8601Date!
}
type ChangeLogMilestoneScheduleDateChange {
  "Can be null, when the milestoneSchedule was deleted. (resolved via Federation)"
  milestoneSchedule: MilestoneSchedule
  changedFrom: ISO8601Date
  changedTo: ISO8601Date
}
type ChangeLogMilestoneScheduleDeleted {
  name: String!
  date: ISO8601Date!
}
type ChangeLogMilestoneScheduleDependencyCreated {
  "Can be null, when the source project schedule was deleted. (resolved via Federation)"
  fromProjectSchedule: ProjectSchedule
  "Can be null, when the source milestone was deleted. (resolved via Federation)"
  fromMilestoneSchedule: MilestoneSchedule
  "Can be null, when the target project schedule was deleted. (resolved via Federation)"
  toProjectSchedule: ProjectSchedule
  "Can be null, when the target milestone was deleted. (resolved via Federation)"
  toMilestoneSchedule: MilestoneSchedule
}
type ChangeLogMilestoneScheduleDependencyDeleted {
  "Can be null, when the source project schedule was deleted. (resolved via Federation)"
  fromProjectSchedule: ProjectSchedule
  "Can be null, when the source milestone was deleted. (resolved via Federation)"
  fromMilestoneSchedule: MilestoneSchedule
  "Can be null, when the target project schedule was deleted. (resolved via Federation)"
  toProjectSchedule: ProjectSchedule
  "Can be null, when the target milestone was deleted. (resolved via Federation)"
  toMilestoneSchedule: MilestoneSchedule
}
type ChangeLogObsReferenceFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: ObsReferenceFieldDefinition
  "Can be null, when the obs unit was deleted. (resolved via Federation)"
  obsUnitChangedFrom: ObsUnitOptional
  "Can be null, when the obs unit was deleted. (resolved via Federation)"
  obsUnitChangedTo: ObsUnitOptional
}
type ChangeLogProgramCreated {
  name: String!
}
type ChangeLogProgramDuplicated {
  name: String!
  "Can be null, when the source program was deleted. (resolved via Federation)"
  sourceProgram: Program
}
type ChangeLogProgramNameChange {
  programNameChangedFrom: String!
  programNameChangedTo: String!
}
type ChangeLogProgramNameUnified {
  programNameChangedFrom: String!
  programNameChangedTo: String!
}
type ChangeLogProjectActualFinancialEventAmountChanged {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  amountChangedFrom: Float!
  amountChangedTo: Float!
}
type ChangeLogProjectActualFinancialEventBookingDateChanged {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  bookingDateChangedFrom: ISO8601Date!
  bookingDateChangedTo: ISO8601Date!
}
type ChangeLogProjectActualFinancialEventCategoryChanged {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  categoryChangedFrom: FinanceCategory
  categoryChangedTo: FinanceCategory
}
type ChangeLogProjectActualFinancialEventCreated {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  bookingDate: ISO8601Date!
  amount: Float!
  type: FinanceType!
}
type ChangeLogProjectActualFinancialEventDeleted {
  bookingDate: ISO8601Date!
  amount: Float!
  type: FinanceType!
}
type ChangeLogProjectActualFinancialEventDescriptionChanged {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  descriptionChangedFrom: String
  descriptionChangedTo: String
}
type ChangeLogProjectActualFinancialEventTypeChanged {
  "Can be null, when the actual financial event was deleted. (resolved via Federation)"
  actualFinancialEvent: ActualFinancialEvent
  typeChangedFrom: FinanceType!
  typeChangedTo: FinanceType!
}
type ChangeLogProjectActualsChanged {
  actualsReferenceEntityType: ActualsReferenceEntityType!
  "Can be null, when the actuals reference entity (resource or role) was deleted. (resolved via Federation)"
  actualsReferenceEntity: ActualsReferenceEntity
  date: ISO8601Date!
  actualsChangedFrom: Float!
  actualsChangedTo: Float!
}
type ChangeLogProjectActualsConnection {
  edges: [ChangeLogProjectActualsEdge!]!
  pageInfo: ForwardPageInfo!
}
type ChangeLogProjectActualsCreated {
  actualsReferenceEntityType: ActualsReferenceEntityType!
  "Can be null, when the actuals reference entity (resource or role) was deleted. (resolved via Federation)"
  actualsReferenceEntity: ActualsReferenceEntity
  date: ISO8601Date!
  actuals: Float!
  "Is null when user does not have finance right or the message is older and does therefore not support the cost info"
  costInfo: ActualsCostInfo
}
type ChangeLogProjectActualsDeleted {
  actualsReferenceEntityType: ActualsReferenceEntityType!
  "Can be null, when the actuals reference entity (resource or role) was deleted. (resolved via Federation)"
  actualsReferenceEntity: ActualsReferenceEntity
  date: ISO8601Date!
  actuals: Float!
  "Is null when user does not have finance right or the message is older and does therefore not support the cost info"
  costInfo: ActualsCostInfo
}
type ChangeLogProjectActualsEdge {
  cursor: String
  node: ChangeLogProjectActuals
}
type ChangeLogProjectActualsGroup {
  id: ID
  changes(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String  ): ChangeLogProjectActualsConnection
}
type ChangeLogProjectAllocationChanged {
  "Can be null, when the allocatee (resource or role) was deleted. (resolved via Federation)"
  allocatee: Allocatee
  "Can be null, when the projectSchedule was deleted. (resolved via Federation)"
  projectSchedule: ProjectSchedule
  isRole: Boolean!
  start: ISO8601Date!
  end: ISO8601Date!
  changedFrom: Float!
  changedTo: Float!
}
type ChangeLogProjectAllocationConnection {
  edges: [ChangeLogProjectAllocationEdge!]!
  pageInfo: ForwardPageInfo!
}
type ChangeLogProjectAllocationCreated {
  "Can be null, when the allocatee (resource or role) was deleted. (resolved via Federation)"
  allocatee: Allocatee
  "Can be null, when the projectSchedule was deleted. (resolved via Federation)"
  projectSchedule: ProjectSchedule
  isRole: Boolean!
}
type ChangeLogProjectAllocationDeleted {
  "Can be null, when the allocatee (resource or role) was deleted. (resolved via Federation)"
  allocatee: Allocatee
  "Can be null, when the projectSchedule was deleted. (resolved via Federation)"
  projectSchedule: ProjectSchedule
  isRole: Boolean!
  allocationInHours: Float!
}
type ChangeLogProjectAllocationEdge {
  cursor: String
  node: ChangeLogProjectAllocation
}
type ChangeLogProjectAllocationGroup {
  id: ID
  changes(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String  ): ChangeLogProjectAllocationConnection
}
type ChangeLogProjectFinanceAmountChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  changedFrom: Float!
  changedTo: Float!
}
type ChangeLogProjectFinanceCategoryChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  financeCategoryChangedFrom: FinanceCategoryOptional
  financeCategoryChangedTo: FinanceCategoryOptional
}
type ChangeLogProjectFinanceCreated {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  amount: Float!
}
type ChangeLogProjectFinanceDateChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  changedFrom: ISO8601Date!
  changedTo: ISO8601Date!
}
type ChangeLogProjectFinanceDeleted {
  timing: FinanceTiming!
  "Can be null, when the milestoneSchedule was deleted. (resolved via Federation)"
  milestoneSchedule: MilestoneSchedule
  date: ISO8601Date!
  amount: Float!
}
type ChangeLogProjectFinanceDescriptionChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  changedFrom: String
  changedTo: String
}
type ChangeLogProjectFinanceMilestoneScheduleChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  milestoneScheduleChangedFrom: MilestoneSchedule
  milestoneScheduleChangedTo: MilestoneSchedule
}
type ChangeLogProjectFinanceTimingChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  financeTimingChangedFrom: FinanceTiming!
  milestoneScheduleChangedFrom: MilestoneSchedule
  financeTimingChangedTo: FinanceTiming!
  milestoneScheduleChangedTo: MilestoneSchedule
}
type ChangeLogProjectFinanceTypeChange {
  """
  This is a workaround since the ProjectFinance type is an interface and subtypes are not known in the change log.
  One of the entries in the list should be non null and therefore it is the correct finance type there.
  If all are null, then the referenced ProjectFinance is deleted. (resolved via Federation)
  """
  financeWorkaround: [ChangeLogProjectFinance]!
  changedFrom: FinanceType!
  changedTo: FinanceType!
}
type ChangeLogProjectScheduleAppliedFromScenario {
  "Can be null, when the source scenario was deleted. (resolved via Federation)"
  sourceScenario: Scenario
}
type ChangeLogProjectScheduleChange {
  changedFields: [ChangeLogProjectScheduleChangeField]
  insertedPeriod: InsertedPeriod
  removedPeriod: RemovedPeriod
  action: ScheduleChangeAction
}
type ChangeLogProjectScheduleCreated {
  name: String!
  start: ISO8601Date!
  finish: ISO8601Date!
}
type ChangeLogProjectScheduleCreatedFromScenario {
  "Can be null, when the source scenario was deleted. (resolved via Federation)"
  sourceScenario: Scenario
}
type ChangeLogProjectScheduleDuplicated {
  name: String!
  start: ISO8601Date!
  finish: ISO8601Date!
  "Can be null, when the source project was deleted. (resolved via Federation)"
  sourceProject: Project
}
type ChangeLogResourceReferenceFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: ResourceReferenceFieldDefinition
  "Can be null, when the resource was deleted. (resolved via Federation)"
  resourceChangedFrom: ResourceOptional
  "Can be null, when the resource was deleted. (resolved via Federation)"
  resourceChangedTo: ResourceOptional
}
type ChangeLogStringFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: StringFieldDefinition
  changedFrom: String
  changedTo: String
}
type ChangeLogSystem {
  _: Boolean
}
type ChangeLogTextFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: TextFieldDefinition
  changedFrom: String
  changedTo: String
}
type ChangeLogUrlFieldChange {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: UrlFieldDefinition
  changedFrom: String
  changedTo: String
}
type ChangeMyActiveCompareToScenarioPayload {
  mySettings: MySettings
  userError: ChangeMyActiveCompareToScenarioUserError
}
type ChangeMyActiveCompareToScenarioUserError {
  message: String!
  type: ChangeMyActiveCompareToScenarioErrorType!
  path: [String!]!
}
type ChangeMyActivePortfolioPayload {
  mySettings: MySettings
  userError: ChangeMyActivePortfolioUserError
}
type ChangeMyActivePortfolioUserError {
  message: String!
  type: ChangeMyActivePortfolioErrorType!
  path: [String!]!
}
type ChangeMyActiveScenarioPayload {
  mySettings: MySettings
  userError: ChangeMyActiveScenarioUserError
}
type ChangeMyActiveScenarioUserError {
  message: String!
  type: ChangeMyActiveScenarioErrorType!
  path: [String!]!
}
type ChargeBear {
  baseUrlExternal: String!
}
type CommentCanary {
  baseUrlExternal: String!
}
type CommentsNotificationSettings {
  id: ID!
  enabled: Boolean!
}
type CommentsNotificationSettingsUpdateEnabledPayload {
  commentsNotificationSettings: CommentsNotificationSettings!
}
type ConfigCentipede {
  baseUrlExternal: String!
}
type CostTypeField {
  costTypeFieldDefinition: CostTypeFieldDefinition!
  costTypeValue: CostType!
}
type CostTypeFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type Currency {
  code: String!
  symbol: String!
}
type DateField {
  dateFieldDefinition: DateFieldDefinition!
  dateValue: ISO8601Date
}
type DateFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type DateRangeConfigurationPayload {
  mySettings: MySettings
  userError: DateRangeConfigurationUserError
}
type DateRangeConfigurationUserError {
  message: String!
  type: DateRangeConfigurationErrorType!
  path: [String!]!
}
type DateTimeField {
  dateTimeFieldDefinition: DateTimeFieldDefinition!
  dateTimeValue: ISO8601DateTime
}
type DateTimeFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type DecimalField {
  decimalFieldDefinition: DecimalFieldDefinition!
  decimalValue: Float
}
type DecimalFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  decimalPlaces: Int!
  unit: DecimalFieldUnit
  nonNegative: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type DefaultCalendarSetPayload {
  userError: DefaultCalendarSetUserError
}
type DefaultCalendarSetUserError {
  message: String!
  type: DefaultCalendarSetErrorType!
  path: [String!]!
}
type EmploymentPeriod {
  start: ISO8601Date
  termination: ISO8601Date
}
type ExportEel {
  baseUrlExternal: String!
}
type FilterFalcon {
  baseUrlExternal: String!
}
type FinanceCategory {
  id: ID!
  externalId: String!
  name: String!
}
type FinanceCategoryEmpty {
  _: Boolean
}
type FixedDateRangeConfiguration {
  startMonth: Int!
  startYear: Int!
  endMonth: Int!
  endYear: Int!
}
type ForwardPageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating forwards, the cursor to continue."
  endCursor: String
}
type HistoryHamster {
  baseUrlExternal: String!
}
type InactivityTimeout {
  minutes: Int!
}
type InactivityTimeoutUpdateError {
  message: String!
  type: InactivityTimeoutUpdateErrorType!
  path: [String!]!
}
type InactivityTimeoutUpdatePayload {
  inactivityTimeout: InactivityTimeout
  userErrors: [InactivityTimeoutUpdateError!]!
}
type InsertedPeriod {
  start: ISO8601Date
  end: ISO8601Date
}
type Instance {
  licenseRelevantInformation: LicenseRelevantInformation!
  fiscalYearStartMonth: Int!
  personDayInHours: Float!
  useYearOfFiscalYearStart: Boolean!
  currency: Currency!
}
type InstanceUpdatePersonDayInHoursPayload {
  userError: InstanceUpdatePersonDayInHoursUserError
  instance: Instance
}
type InstanceUpdatePersonDayInHoursUserError {
  message: String!
  type: InstanceUpdatePersonDayInHoursErrorType!
  path: [String!]!
}
type IntegerField {
  integerFieldDefinition: IntegerFieldDefinition!
  integerValue: Float
}
type IntegerFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type IntegrationIbex {
  baseUrlExternal: String!
}
type JiraDurationEstimate {
  hours: Float!
  "Hours value converted with person day in hours factor from Meisterplan"
  days: Float!
}
type JiraEffortFieldDefinition {
  "This id is the jira field id and is not controlled by meisterplan"
  id: ID!
  fieldType: JiraEffortType!
  name: String!
}
type JiraEpic {
  key: String!
  epicName: String!
  summary: String!
  status: String!
  url: String!
  startDate: ISO8601Date
  dueDate: ISO8601Date
}
type JiraEpicsConnection {
  edges: [JiraEpicsEdge!]!
  pageInfo: PageInfo!
  totalEdges: Int!
}
type JiraEpicsEdge {
  cursor: String!
  node: JiraEpic!
}
type JiraIssue {
  name: String!
  url: String!
  roleAssignee: JiraRoleAssignee
  resourceAssignee: JiraResourceAssignee
  estimate: JiraEstimate!
  projectModeAllocationInHours: Float!
  status: JiraIssueStatus!
}
type JiraIssueConnection {
  edges: [JiraIssuesEdge!]!
  pageInfo: PageInfo!
  totalEdges: Int!
}
type JiraIssuesEdge {
  cursor: String!
  node: JiraIssue!
}
type JiraLink {
  id: ID!
  name: String!
  url: String!
  type: JiraLinkType!
  ignoreCertificate: Boolean!
  mappingMode: JiraLinkMappingMode!
  velocity: Float
  """
  'fieldConfiguration' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  """
  fieldConfiguration(encryptedJiraCredentials: String!): JiraLinkFieldConfiguration!
  """
  'userDetails' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  """
  userDetails(encryptedJiraCredentials: String!): JiraRemoteUserDetails!
  """
  'epics' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  - OTHER: if error is unknown
  """
  jiraEpics(first: Int!, after: String, filter: JiraEpicsFilterInput, sorting: JiraEpicsSortingInput, encryptedJiraCredentials: String!): JiraEpicsConnection!
}
type JiraLinkCreateError {
  message: String!
  path: [String!]!
  type: JiraLinkCreateErrorType
}
type JiraLinkCreatePayload {
  userError: JiraLinkCreateError
  jiraLink: JiraLink
}
type JiraLinkDeleteError {
  message: String!
  path: [String!]!
  type: JiraLinkDeleteErrorType
}
type JiraLinkDeletePayload {
  userError: JiraLinkDeleteError
}
type JiraLinkFieldConfiguration {
  selectedEffortField: JiraEffortFieldDefinition
  effortFields: [JiraEffortFieldDefinition!]!
  selectedResourceEffortField: JiraEffortFieldDefinition
  selectedMatchRolesToJiraField: JiraMatchRolesFieldDefinition
  matchRolesToJiraFields: [JiraMatchRolesFieldDefinition!]!
}
type JiraLinkUpdateError {
  message: String!
  path: [String!]!
  type: JiraLinkUpdateErrorType
}
type JiraLinkUpdatePayload {
  userError: JiraLinkUpdateError
  jiraLink: JiraLink
}
type JiraMatchRolesFieldDefinition {
  "This id is the jira field id and is not controlled by meisterplan"
  id: ID!
  name: String!
}
type JiraProjectLink {
  id: ID!
  jiraLink: JiraLink!
  projectLinkType: JiraProjectLinkType!
  "The link is an epic key or a jql expression depending on the projectLinkType"
  link: String!
  url: String!
  """
  'epicName' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  - JIRA_EPIC_NOT_FOUND: if the linked epic could not be found or the user has no permission.
  """
  epicName(encryptedJiraCredentials: String!): String
  """
  'jiraIssues' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  - JIRA_ESTIMATE_FIELD_NOT_FOUND: if estimate field specified in the settings could not be found in JIRA.
  - JIRA_RESOURCE_ESTIMATE_FIELD_NOT_FOUND: if resource estimate field specified in the settings could not be found in JIRA.
  - JIRA_EPIC_NOT_FOUND: if the linked epic could not be found or the user has no permission.
  - JIRA_JQL_NOT_FOUND: if the JQL is invalid.
  """
  jiraIssues(first: Int!, after: String, encryptedJiraCredentials: String!): JiraIssueConnection!
  """
  'jiraIssues' needs valid Jira credentials. It can fail with the GraphQL errors of type:
  - JIRA_TIMEOUT: if connection to Jira timed out.
  - JIRA_INVALID_CREDENTIALS: if the access token is not valid, expired or does not match the jira link.
  - JIRA_ACCOUNT_LOCKED: if the user's Jira account is locked.
  - JIRA_INVALID_CONFIGURATION: if the user's Jira configuration is invalid (e.g. using a private ip).
  - JIRA_ESTIMATE_FIELD_NOT_FOUND: if estimate field specified in the settings could not be found in JIRA.
  - JIRA_RESOURCE_ESTIMATE_FIELD_NOT_FOUND: if resource estimate field specified in the settings could not be found in JIRA.
  - JIRA_EPIC_NOT_FOUND: if the linked epic could not be found or the user has no permission.
  - JIRA_JQL_NOT_FOUND: if the JQL is invalid.
  """
  legacyJiraIssues(encryptedJiraCredentials: String!): [JiraIssue!]!
}
type JiraProjectLinkCreateOrUpdateError {
  message: String!
  path: [String!]!
  type: JiraProjectLinkCreateOrUpdateErrorType!
}
type JiraProjectLinkCreateOrUpdatePayload {
  userError: JiraProjectLinkCreateOrUpdateError
  project: Project
}
type JiraProjectLinkDeleteError {
  message: String!
  path: [String!]!
  type: JiraProjectLinkDeleteErrorType!
}
type JiraProjectLinkDeletePayload {
  userError: JiraProjectLinkDeleteError
  project: Project
}
type JiraRemoteUserDetails {
  userName: String!
}
type JiraResourceAssignee {
  assignee: Resource!
  allocationInHours: Float!
}
type JiraRoleAssignee {
  assignee: Role!
  allocationInHours: Float!
}
type JiraStoryPointsEstimate {
  storyPoints: Float!
}
type License {
  trial: Boolean!
  licenseType: LicenseType!
  packageId: String
  packageName: String
  contractEndDate: ISO8601Date
  licensedResourceCount: Int
  reseller: Boolean!
  shopUrl: String
  featureSetId: String!
}
type LicenseRelevantInformation {
  resourceActiveCount: Int!
  maxRoleCapacity: MaxRoleCapacity!
}
type LinkLynx {
  baseUrlExternal: String!
}
type ListyLlama {
  baseUrlExternal: String!
}
type LoginNoticeUpdateError {
  message: String!
  type: LoginNoticeUpdateErrorType!
  path: [String!]!
}
type LoginNoticeUpdatePayload {
  authenticationSettings: AuthenticationSettings
  userErrors: [LoginNoticeUpdateError!]!
}
type LookupField {
  lookupFieldDefinition: LookupFieldDefinition!
  lookupValue: LookupFieldValue
}
type LookupFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
  "LookupField is relevant for the calculation of the project score if one of the values has a score <> 0."
  scoreRelevant: Boolean!
  values: [LookupFieldValue!]!
}
type LookupFieldValue {
  id: ID!
  externalId: String!
  name: String!
  color: HexColorCode
  "Missing license for PROJECT_SCORE feature returns null"
  scoreContribution: Int
}
type LookupFieldValueCreatePayLoad {
  userError: LookupFieldValueCreateUserError
  lookupFieldValue: LookupFieldValue
}
type LookupFieldValueCreateUserError {
  message: String!
  type: LookupFieldValueCreateErrorType!
  path: [String!]!
}
type LookupFieldValueEmpty {
  _: Boolean
}
type MailMeerkat {
  baseUrlExternal: String!
}
type MaskedIcebear {
  baseUrlExternal: String!
}
type MaxRoleCapacity {
  maxRoleCapacityScenario: Scenario!
  roleActiveFte: Float!
}
type MeAcknowledgeProjectEditTipPayload {
  mySettings: MySettings
}
type Milestone {
  id: ID!
  externalId: String!
  name: String!
  phase: ProjectPhase
  milestoneSchedule(scenarioId: ID!): MilestoneSchedule
}
type MilestoneSchedule {
  id: ID!
  milestone: Milestone!
  date: ISO8601Date!
  projectSchedule: ProjectSchedule!
  requires: [MilestoneSchedule!]!
  isRequiredBy: [MilestoneSchedule!]!
}
type MilestoneScheduleCreatePayload {
  userError: MilestoneScheduleCreateUserError
  milestoneSchedule: MilestoneSchedule
}
type MilestoneScheduleCreateUserError {
  message: String!
  type: MilestoneScheduleCreateErrorType!
  path: [String!]!
}
type MilestoneScheduleDeletePayload {
  userError: MilestoneScheduleDeleteUserError
  projectSchedule: ProjectSchedule
}
type MilestoneScheduleDeleteUserError {
  message: String!
  type: MilestoneScheduleDeleteErrorType!
  path: [String!]!
}
type MilestoneScheduleDependency {
  fromMilestoneSchedule: MilestoneSchedule!
  toMilestoneSchedule: MilestoneSchedule!
}
type MilestoneScheduleDependencyConnection {
  edges: [MilestoneScheduleDependencyEdge!]!
  pageInfo: PageInfo!
}
type MilestoneScheduleDependencyCreatePayload {
  userError: MilestoneScheduleDependencyCreateUserError
  milestoneScheduleDependency: MilestoneScheduleDependency
}
type MilestoneScheduleDependencyCreateUserError {
  message: String!
  type: MilestoneScheduleDependencyCreateErrorType!
  path: [String!]!
}
type MilestoneScheduleDependencyDeletePayload {
  userError: MilestoneScheduleDependencyDeleteUserError
}
type MilestoneScheduleDependencyDeleteUserError {
  message: String!
  type: MilestoneScheduleDependencyDeleteErrorType!
  path: [String!]!
}
type MilestoneScheduleDependencyEdge {
  cursor: String!
  node: MilestoneScheduleDependency!
}
type MilestoneScheduleUpdateDatePayload {
  userError: MilestoneScheduleUpdateDateUserError
  milestoneSchedule: MilestoneSchedule
}
type MilestoneScheduleUpdateDateUserError {
  message: String!
  type: MilestoneScheduleUpdateDateErrorType!
  path: [String!]!
}
type MilestoneUpdateNamePayload {
  userError: MilestoneUpdateNameUserError
  milestone: Milestone
}
type MilestoneUpdateNameUserError {
  message: String!
  type: MilestoneUpdateNameErrorType!
  path: [String!]!
}
type MilestoneUpdateProjectPhasePayload {
  userError: MilestoneUpdateProjectPhaseUserError
  milestone: Milestone
}
type MilestoneUpdateProjectPhaseUserError {
  message: String!
  type: MilestoneUpdateProjectPhaseErrorType!
  path: [String!]!
}
type Mutation {
  """
  Create a new webhook.
  Requires user permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS.
  """
  webhookCreate(input: WebhookCreateInput!): WebhookCreatePayload!
  """
  Update the status of an existing webhook.
  Requires user permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS.
  """
  webhookUpdateStatus(input: WebhookUpdateStatusInput!): WebhookUpdateStatusPayload!
  """
  Delete an existing webhook.
  Requires user permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS.
  """
  webhookDelete(input: WebhookDeleteInput!): WebhookDeletePayload!
  """
  Add a new business goal.
  Requires user permission 'MANAGE_PROJECT_FIELDS'.
  """
  businessGoalCreate(input: BusinessGoalCreateInput!): BusinessGoalCreatePayload!
  """
  Add a new calendar.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  calendarCreate(input: CalendarCreateInput!): CalendarCreatePayload!
  """
  Delete an existing calendar.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  calendarDelete(input: CalendarDeleteInput!): CalendarDeletePayload!
  """
  Update an existing calendar.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  calendarUpdate(input: CalendarUpdateInput!): CalendarUpdatePayload!
  """
  Change the system's default calendar.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  defaultCalendarSet(input: DefaultCalendarSetInput!): DefaultCalendarSetPayload!
  """
  Specify the number of hours a full working day has for your system.
  Requires user permission 'MANAGE_PROJECT_FIELDS'.
  """
  instanceUpdatePersonDayInHours(input: InstanceUpdatePersonDayInHoursInput!): InstanceUpdatePersonDayInHoursPayload!
  "Add a new value to a field's lookup values."
  lookupFieldValueCreate(input: LookupFieldValueCreateInput!): LookupFieldValueCreatePayLoad!
  """
  Acknowledge that you saw the tip how to edit a project.
  You will continue to see the tip until you call this mutation.
  """
  meAcknowledgeProjectEditTip: MeAcknowledgeProjectEditTipPayload!
  """
  Update the name of a milestone.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario, the milestone to be scheduled in the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneUpdateName(input: MilestoneUpdateNameInput!): MilestoneUpdateNamePayload!
  """
  Update the project phase of a milestone.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario, the milestone to be scheduled in the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneUpdateProjectPhase(input: MilestoneUpdateProjectPhaseInput!): MilestoneUpdateProjectPhasePayload!
  """
  Add a milestone to a project schedule.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneScheduleCreate(input: MilestoneScheduleCreateInput!): MilestoneScheduleCreatePayload!
  """
  Delete a milestone from a project schedule.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneScheduleDelete(input: MilestoneScheduleDeleteInput!): MilestoneScheduleDeletePayload!
  """
  Update the date of a milestone schedule.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario of the milestone schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneScheduleUpdateDate(input: MilestoneScheduleUpdateDateInput!): MilestoneScheduleUpdateDatePayload!
  """
  Create a milestone dependency between the two specified milestone schedules.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario of the milestone schedules and the scenario not to be archived.
  The requesting user must be the project manager of at least one of the affected projects or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneScheduleDependencyCreate(input: MilestoneScheduleDependencyCreateInput!): MilestoneScheduleDependencyCreatePayload!
  """
  Delete the milestone dependency between the two specified milestone schedules.
  Requires user permission 'ADD_CHANGE_AND_DELETE_MILESTONES'.
  Requires the requesting user to be assigned to the scenario of the milestone schedules and the scenario not to be archived.
  The requesting user must be the project manager of at least one of the affected projects or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  milestoneScheduleDependencyDelete(input: MilestoneScheduleDependencyDeleteInput!): MilestoneScheduleDependencyDeletePayload!
  "Update the week display unit setting of the requesting user"
  mySettingsUpdateWeekDisplayUnit(input: MySettingsUpdateWeekDisplayUnitInput!): MySettingsUpdateWeekDisplayUnitPayload!
  """
  Update an OBS type's name.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  obsTypeUpdateName(input: ObsTypeUpdateNameInput!): ObsTypeUpdateNamePayload!
  """
  Delete an existing OBS type.
  All descendant OBS units and all associations to project, resources and roles will also be removed.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  obsTypeDelete(input: ObsTypeDeleteInput!): ObsTypeDeletePayload!
  """
  Update an OBS unit's name.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  obsUnitUpdateName(input: ObsUnitUpdateNameInput!): ObsUnitUpdateNamePayload!
  """
  Update an OBS unit's parent.
  This operation does not allow to change a unit's parent to a unit of a different type.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  obsUnitUpdateParent(input: ObsUnitUpdateParentInput!): ObsUnitUpdateParentPayload!
  """
  Retrieve the desired organisational breakdown structure.
  If the type or any of the units inside the requested structure can't be found, they will be created.
  This can lead to the entire structure of the specified type being just returned, partially created or fully created.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  obsUnitFindOrCreate(input: ObsUnitFindOrCreateInput!): ObsUnitFindOrCreatePayload!
  obsUnitCreate(input: ObsUnitCreateInput!): ObsUnitCreatePayload!
  """
  Create an empty OBS type.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  obsTypeCreate(input: ObsTypeCreateInput!): ObsTypeCreatePayload!
  """
  Delete an existing OBS unit. All children of the OBS unit are deleted recursively as well.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  obsUnitDelete(input: ObsUnitDeleteInput!): ObsUnitDeletePayload!
  """
  Change the rank category of existing project schedules and program schedules by ranking them accordingly.
  Requires the requesting user to have scenario write permission and 'CHANGE_PROJECT_RANK' permission and the scenario not to be archived.
  """
  prioritiesRankIntoRankCategory(input: PrioritiesRankIntoRankCategoryInput!): PrioritiesRankIntoRankCategoryPayload!
  """
  Add a program schedule to a scenario.
  Requires `CREATE_PROJECTS` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleCreate(input: ProgramScheduleCreateInput!): ProgramScheduleCreatePayload!
  """
  Duplicate an existing program schedule including all its project schedules.
  Requires `ADD_PROJECTS_AND_PROGRAMS` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleDuplicate(input: ProgramScheduleDuplicateInput!): ProgramScheduleDuplicatePayload!
  """
  Rank a program schedule relative to another program schedule.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleRankRelativeToProgramSchedule(input: ProgramScheduleRankRelativeToProgramScheduleInput!): ProgramScheduleRankRelativeToProgramSchedulePayload!
  """
  Rank a program schedule relative to a project schedule.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleRankRelativeToProjectSchedule(input: ProgramScheduleRankRelativeToProjectScheduleInput!): ProgramScheduleRankRelativeToProjectSchedulePayload!
  """
  Update a program's name.
  Requires the requesting user to have scenario edit rights on the scenario containing the program to update.
  """
  programUpdateName(input: ProgramUpdateNameInput!): ProgramUpdateNamePayload!
  """
  Remove an existing program schedule from your system.
  Requires `DELETE_PROJECTS` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleDelete(input: ProgramScheduleDeleteInput!): ProgramScheduleDeletePayload!
  """
  Rank the program schedule by its score.
  The project score of a program schedule is the maximum score of its contained project schedules.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  programScheduleRankByScore(input: ProgramScheduleRankByScoreInput!): ProgramScheduleRankByScorePayload!
  """
  Add a project finance with type project start to a project schedule.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectStartFinanceCreate(input: ProjectStartFinanceCreateInput!): ProjectStartFinanceCreatePayload!
  """
  Add a project finance with type project finish to a project schedule.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinishFinanceCreate(input: ProjectFinishFinanceCreateInput!): ProjectFinishFinanceCreatePayload!
  """
  Add a project finance with type project milestone to a project schedule.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectMilestoneFinanceCreate(input: ProjectMilestoneFinanceCreateInput!): ProjectMilestoneFinanceCreatePayload!
  """
  Add a project finance with date to a project schedule.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectDateFinanceCreate(input: ProjectDateFinanceCreateInput!): ProjectDateFinanceCreatePayload!
  """
  Remove an existing project finance from your system.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceDelete(input: ProjectFinanceDeleteInput!): ProjectFinanceDeletePayload!
  """
  Move an existing project finance to a specific date.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceMoveToDate(input: ProjectFinanceMoveToDateInput!): ProjectFinanceMoveToDatePayload!
  """
  Move an existing project finance to the timing of a milestone within the same project.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceMoveToMilestone(input: ProjectFinanceMoveToMilestoneInput!): ProjectFinanceMoveToMilestonePayload!
  """
  Move an existing project finance to the start date of the associated project.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceMoveToProjectStart(input: ProjectFinanceMoveToProjectStartInput!): ProjectFinanceMoveToProjectStartPayload!
  """
  Move an existing project finance to the finish date of the associated project.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceMoveToProjectFinish(input: ProjectFinanceMoveToProjectFinishInput!): ProjectFinanceMoveToProjectFinishPayload!
  """
  Updates the description of an existing project finance.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceUpdateDescription(input: ProjectFinanceUpdateDescriptionInput!): ProjectFinanceUpdateDescriptionPayload!
  """
  Updates the finance category of an existing project finance.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceUpdateFinanceCategory(input: ProjectFinanceUpdateFinanceCategoryInput!): ProjectFinanceUpdateFinanceCategoryPayload!
  """
  Updates the finance type of an existing project finance.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceUpdateType(input: ProjectFinanceUpdateTypeInput!): ProjectFinanceUpdateTypePayload!
  """
  Updates the value of an existing project finance.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectFinanceUpdateValue(input: ProjectFinanceUpdateValueInput!): ProjectFinanceUpdateValuePayload!
  """
  Remove an existing project schedule from your system.
  Requires `DELETE_PROJECTS` permission, the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectScheduleDelete(input: ProjectScheduleDeleteInput!): ProjectScheduleDeletePayload!
  """
  Duplicate an existing project schedule
  Requires `ADD_PROJECTS_AND_PROGRAMS`, `MODIFY_PROJECTS_AND_PROGRAMS` and
  the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  projectScheduleDuplicate(input: ProjectScheduleDuplicateInput!): ProjectScheduleDuplicatePayload!
  """
  Move a project schedule to a certain date.
  Requires `CHANGE_PROJECT_SCHEDULE` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectScheduleMovePeriod(input: ProjectScheduleMovePeriodInput!): ProjectScheduleMovePeriodPayload!
  """
  Rank the project schedule by its score.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  Is only applicable on project schedules that are not part of a program schedule.
  """
  projectScheduleRankByScore(input: ProjectScheduleRankByScoreInput!): ProjectScheduleRankByScorePayload!
  """
  Rank a project schedule relative to a program schedule.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  projectScheduleRankRelativeToProgramSchedule(input: ProjectScheduleRankRelativeToProgramScheduleInput!): ProjectScheduleRankRelativeToProgramSchedulePayload!
  """
  Rank a project schedule relative to another project schedule.
  Requires `CHANGE_PROJECT_RANK` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  projectScheduleRankRelativeToProjectSchedule(input: ProjectScheduleRankRelativeToProjectScheduleInput!): ProjectScheduleRankRelativeToProjectSchedulePayload!
  """
  Change the duration of a project schedule.
  Requires `CHANGE_PROJECT_SCHEDULE` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectScheduleUpdateDuration(input: ProjectScheduleUpdateDurationInput!): ProjectScheduleUpdateDurationPayload!
  """
  Insert a project break into a project schedule.
  The project break will be modeled using zero-allocations.
  The project time period will be extended by the duration of the break.
  """
  projectScheduleInsertBreak(input: ProjectScheduleInsertBreakInput!): ProjectScheduleInsertBreakPayload!
  """
  Extend project schedule allocations.
  The allocations on the specified date are extended with the set values.
  The project time period will be extended by the duration of the allocation.
  """
  projectScheduleExtendAllocations(input: ProjectScheduleExtendAllocationsInput!): ProjectScheduleExtendAllocationsPayload!
  """
  Removes a section from a project schedule.
  Requires user permission `CHANGE_PROJECT_SCHEDULE`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The specified section must be within the project period.
  Allocation segments and milestone schedules within this section and their milestone schedule dependencies will be deleted.
  If a deleted milestone is linked to a financial event, the type of the event is changed to a custom date.
  """
  projectScheduleRemoveSection(input: ProjectScheduleRemoveSectionInput!): ProjectScheduleRemoveSectionPayload!
  """
  Replace all allocations on a project schedule.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  projectScheduleReplaceAllocations(input: ProjectScheduleReplaceAllocationsInput!): ProjectScheduleReplaceAllocationsPayload!
  "Splits all allocations at a given date."
  projectScheduleSplitAllocationsAtDate(input: ProjectScheduleSplitAllocationsAtDateInput!): ProjectScheduleSplitAllocationsAtDatePayload!
  """
  Submits a project schedule from one scenario to another.
  If a schedule for the specified project already exists in the target scenario, its properties including period, milestone schedules, finances and
  allocations will be overwritten. Otherwise a new project schedule will be created.
  The project schedule's rank category and program association will be applied to the target, its global rank mimicked as good as possible.
  Requires the requesting user to be assigned to the target scenario and the target scenario not to be archived.
  """
  projectScheduleSubmitToScenario(input: ProjectScheduleSubmitToScenarioInput!): ProjectScheduleSubmitToScenarioPayload!
  """
  Add a project to a scenario, applying values corresponding to the specified portfolio.
  Requires `ADD_PROJECTS_AND_PROGRAMS` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  projectCreate(input: ProjectCreateInput!): ProjectCreatePayload!
  """
  Add a project to a scenario, applying values corresponding to the specified portfolio.
  Requires `ADD_PROJECTS_AND_PROGRAMS` permission, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  projectCreateGeneric(input: ProjectCreateGenericInput!): ProjectCreateGenericPayload!
  """
  Change multiple fields of an existing project.
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  Furthermore the requesting user must be assigned to every field he wants to update.
  """
  projectUpdateFields(input: ProjectUpdateFieldsInput!): ProjectUpdateFieldsPayload!
  """
  Add a resource to your system, which can be allocated to projects and assigned to roles.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceCreate(input: ResourceCreateInput!): ResourceCreatePayload!
  """
  Remove an existing resource from your system.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceDelete(input: ResourceDeleteInput!): ResourceDeletePayload!
  """
  Update an existing resource.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceUpdate(input: ResourceUpdateInput!): ResourceUpdatePayload!
  """
  Set a coherent list of calendar deviations to be added for this resource.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceUpdateCalendarDeviations(input: ResourceUpdateCalendarDeviationsInput!): ResourceUpdateCalendarDeviationsPayload!
  """
  Updates existing absences of a resource.
  Absences can only overlap when the total amount of absences on each day is not more than one full day of absence.
  When duration is exactly one day and either start or end type is "HALF_DAY" (or both) it will be interpreted as "single half day absence".
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceAbsencesUpdate(input: ResourceAbsencesUpdateInput!): ResourceAbsencesUpdatePayload!
  """
  Adds absences to a resource.
  Absences can only overlap when the total amount of absences on each day is not more than one full day of absence.
  When duration is exactly one day and either start or end type is "HALF_DAY" (or both) it will be interpreted as "single half day absence".
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceAbsencesCreate(input: ResourceAbsencesCreateInput!): ResourceAbsencesCreatePayload!
  """
  Deletes existing resource absences.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  resourceAbsencesDelete(input: ResourceAbsencesDeleteInput!): ResourceAbsencesDeletePayload!
  """
  Remove an existing allocation between a project schedule and a resource.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationDelete(input: ResourceAllocationDeleteInput!): ResourceAllocationDeletePayload!
  """
  Create a new allocation between a project schedule and a resource. The allocation to be created must not yet exist.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationCreate(input: ResourceAllocationCreateInput!): ResourceAllocationCreatePayload!
  """
  Update an existing allocation between a project schedule and a resource. The allocation to be updated must exist.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationUpdate(input: ResourceAllocationUpdateInput!): ResourceAllocationUpdatePayload!
  """
  Create or update an existing allocation between a project schedule and a resource. If the allocation does not yet exist it will be created.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationCreateOrUpdate(input: ResourceAllocationCreateOrUpdateInput!): ResourceAllocationCreateOrUpdatePayload!
  """
  Completely or partially transfers an existing allocation from one resource to another.
  If the target allocation does not exist yet, it will be created. If the source allocation remains with zero values only, it will be deleted.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationTransferToResource(input: ResourceAllocationTransferToResourceInput!): ResourceAllocationTransferToResourcePayload!
  """
  Remove an existing allocation between a project schedule and a resource transfering all allocation segments to the assigned project role.
  If the project role is not yet allocated to the project schedule, a corresponding role allocation will be created.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  resourceAllocationUnstaffToProjectRole(input: ResourceAllocationUnstaffToProjectRoleInput!): ResourceAllocationUnstaffToProjectRolePayload!
  """
  Create a new allocation between a project schedule and a role. The allocation to be created must not yet exist.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  roleAllocationCreate(input: RoleAllocationCreateInput!): RoleAllocationCreatePayload!
  """
  Create or update an existing allocation between a project schedule and a role. If the allocation does not yet exist it will be created.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  roleAllocationCreateOrUpdate(input: RoleAllocationCreateOrUpdateInput!): RoleAllocationCreateOrUpdatePayload!
  """
  Remove an existing allocation between a project schedule and a role.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  roleAllocationDelete(input: RoleAllocationDeleteInput!): RoleAllocationDeletePayload!
  """
  Update an existing allocation between a project schedule and a role. The allocation to be updated must exist.
  Requires user permission `ADD_CHANGE_AND_DELETE_ALLOCATIONS`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  roleAllocationUpdate(input: RoleAllocationUpdateInput!): RoleAllocationUpdatePayload!
  """
  Update the additional capacities of a role within a scenario.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`, the requesting user to be assigned to the scenario and the scenario not to be archived.
  """
  roleCapacityUpdateDeviations(input: RoleCapacityUpdateDeviationsInput!): RoleCapacityUpdateDeviationsPayload!
  "Add a role to your system, which can be allocated to projects and assigned to resources."
  roleCreate(input: RoleCreateInput!): RoleCreatePayload!
  """
  Remove an existing role from your system.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`
  """
  roleDelete(input: RoleDeleteInput!): RoleDeletePayload!
  """
  Update an existing role.
  Requires user permission `MANAGE_RESOURCE_POOL_AND_ABSENCES`.
  """
  roleUpdate(input: RoleUpdateInput!): RoleUpdatePayload!
  """
  Copy a given scenario.
  Requires the requesting user to have scenario manage rights.
  Requires the system to have licensed the scenario feature.
  """
  scenarioCopy(input: ScenarioCopyInput!): ScenarioCopyPayload!
  """
  Deletes the given scenario.
  Can not be used to delete the Plan of Record.
  Requires the requesting user to have scenario manage rights.
  """
  scenarioDelete(input: ScenarioDeleteInput!): ScenarioDeletePayload!
  """
  Submits the content of a scenario to the plan of record.
  Project schedules of projects referenced in both the source scenario and the plan of record will be submitted to the plan of record, which means
  its properties including period, milestone schedules, finances and allocations will be overwritten. Project schedules that are missing in the
  source scenario will be deleted from the plan of record, while new project schedules will be created for all project schedules of the source
  scenario not yet included in the plan of record.
  Project schedule rankings and program associations will be synchronized to the plan of record as well as any milestone schedule dependencies and
  role capacity deviations defined in the source scenario.
  Requires user permission 'REPLACE_PLAN_OF_RECORD_WITH_SCENARIO'.
  """
  scenarioSubmitToPlanOfRecord(input: ScenarioSubmitToPlanOfRecordInput!): ScenarioSubmitToPlanOfRecordPayload!
  """
  Update a given scenario.
  Can not be used to update the Plan of Record.
  Requires the requesting user to have scenario manage rights.
  """
  scenarioUpdate(input: ScenarioUpdateInput!): ScenarioUpdatePayload!
  """
  Prioritizes the program schedules and top-level project schedules of a scenario according to their project score with the highest score ending up on top.
  The project score of a project schedule is the sum of all score contributions of the project's field values.
  The project score of a program schedule is the maximum score of its contained project schedules.
  Project schedules without any score contribution are assigned a project score of 0 as are empty program schedules.
  If two or more items score with the same value their current priority is considered to determine who ends up with a higher priority.
  Rank categories keep their cardinality of top-level items. Program schedules keep their inner priorities under all circumstances.
  """
  scenarioPrioritiesRankByProjectScore(input: ScenarioPrioritiesRankByProjectScoreInput!): ScenarioPrioritiesRankByProjectScorePayload!
  """
  Add a skill to your system, which can be assigned to a resource.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  skillCreate(input: SkillCreateInput!): SkillCreatePayload!
  """
  Delete a skill.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  skillDelete(input: SkillDeleteInput!): SkillDeletePayload!
  """
  Update a skill's name.
  Requires user permission 'MANAGE_RESOURCE_POOL_AND_ABSENCES'.
  """
  skillUpdateName(input: SkillUpdateNameInput!): SkillUpdateNamePayload!
  "Set the scenario to load after login to the Meisterplan front end."
  changeMyActiveScenario(input: ChangeMyActiveScenarioInput!): ChangeMyActiveScenarioPayload!
  "Set the scenario to compare the currently active scenario to."
  changeMyActiveCompareToScenario(input: ChangeMyActiveCompareToScenarioInput!): ChangeMyActiveCompareToScenarioPayload!
  "Set the portfolio to load after login to the Meisterplan front end."
  changeMyActivePortfolio(input: ChangeMyActivePortfolioInput!): ChangeMyActivePortfolioPayload!
  "Set the date range to be used in the Meisterplan front end."
  updateDateRange(input: DateRangeConfigurationInput!): DateRangeConfigurationPayload!
  "Specify the workload unit to be used in the Portfolio Designer of the Meisterplan front end."
  updateWorkloadUnit(input: UpdateWorkloadUnitInput!): UpdateWorkloadUnitPayload!
  "Specify the allocation mode to be used in the Portfolio Designer of the Meisterplan front end."
  updateAllocationMode(input: UpdateAllocationModeInput!): UpdateAllocationModePayload!
  resourceKeyGenerate: ResourceKeyGeneratePayload!
  "Demonstration test code only. Do not use productively in Meisterplan services."
  tigerBlogPostPublish(input: TigerBlogPostPublishInput!): TigerBlogPostPublishPayload!
  setOnboardingCenterVisibility(visible: Boolean!): OnboardingData!
  setOnboardingRole(role: OnboardingRole!): OnboardingData!
  completeOnboardingStep(step: String!): OnboardingData!
  selectOnboardingUseCase(useCase: String!): OnboardingData!
  deleteSampleData: OnboardingData!
  """
  Store a boolean state of an onboarding element. Please prefix your `id` with your service name
  (e.g. `myservice.resource-hint`) to prevent name clashes.
  
  - id can be up to 255 chars long
  - max. 1000 flags per user
  """
  onboardingFlagUpdate(input: OnboardingFlagInput!): OnboardingFlagPayload!
  "The permission MANAGE_PROJECT_FIELDS is required."
  projectViewConfigurationSave(sections: [ProjectViewConfigurationSectionInput!]!): ProjectViewConfigurationSavePayload!
  "The permission MANAGE_PROJECT_FIELDS is required."
  projectOverviewConfigurationSave(input: ProjectOverviewConfigurationInput!): ProjectOverviewConfigurationSavePayload
  userResendVerificationMail(input: UserResendVerificationMailInput!): UserResendVerificationMailPayload!
  "Needs User Permission MANAGE_JIRA_LINKS"
  jiraLinkCreate(input: JiraLinkCreateInput!): JiraLinkCreatePayload!
  "Needs User Permission MANAGE_JIRA_LINKS"
  jiraLinkUpdate(input: JiraLinkUpdateInput!): JiraLinkUpdatePayload!
  "Needs User Permission MANAGE_JIRA_LINKS"
  jiraLinkDelete(input: JiraLinkDeleteInput!): JiraLinkDeletePayload!
  """
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  jiraProjectLinkCreateOrUpdate(input: JiraProjectLinkCreateOrUpdateInput!): JiraProjectLinkCreateOrUpdatePayload!
  """
  Requires the requesting user to be assigned to the scenario of the project schedule and the scenario not to be archived.
  The requesting user must also be the project manager of the affected project or have the 'MODIFY_ALL_PROJECTS_AND_PROGRAMS' permission.
  """
  jiraProjectLinkDelete(input: JiraProjectLinkDeleteInput!): JiraProjectLinkDeletePayload!
  "Updates the project manager email notification schedule"
  notificationSettingsProjectManagerEmailScheduleUpdate(notificationSchedule: ProjectManagerEmailNotificationSchedule!): NotificationSettingsProjectManagerEmailScheduleUpdatePayload!
  "Updates the project manager email enabled state"
  notificationSettingsProjectManagerEmailEnabledUpdate(enabled: Boolean!): NotificationSettingsProjectManagerEmailEnabledUpdatePayload!
  "Updates the resource manager email notification schedule"
  notificationSettingsResourceManagerEmailScheduleUpdate(notificationSchedule: ResourceManagerEmailNotificationSchedule!): NotificationSettingsResourceManagerEmailScheduleUpdatePayload!
  "Updates the resource manager email enabled state"
  notificationSettingsResourceManagerEmailEnabledUpdate(enabled: Boolean!): NotificationSettingsResourceManagerEmailEnabledUpdatePayload!
  viewConfigCreate(input: ViewConfigCreateInput!): ViewConfigCreatePayload!
  viewConfigValueUpdate(input: ViewConfigValueUpdateInput!): ViewConfigValueUpdatePayload!
  viewConfigMetaDataUpdate(input: ViewConfigMetaDataUpdateInput!): ViewConfigMetaDataUpdatePayload!
  viewConfigDelete(input: ViewConfigDeleteInput!): ViewConfigDeletePayload!
  viewConfigActivate(input: ViewConfigActivateInput!): ViewConfigActivatePayload!
  projectCommentCreate(input: ProjectCommentCreateInput!): ProjectCommentCreatePayload!
  projectCommentDelete(input: ProjectCommentDeleteInput!): ProjectCommentDeletePayload!
  "Updates the comments email notification enabled state"
  commentsNotificationSettingsUpdateEnabled(enabled: Boolean!): CommentsNotificationSettingsUpdateEnabledPayload!
  userUpdate(input: UserUpdateInput!): UserUpdatePayload!
  userUpdateMyFirstName(input: UserUpdateMyFirstNameInput!): UserUpdateMyFirstNamePayload!
  userUpdateMyLastName(input: UserUpdateMyLastNameInput!): UserUpdateMyLastNamePayload!
  userUpdateMyLocale(input: UserUpdateMyLocaleInput!): UserUpdateMyLocalePayload!
  """
  Update the linked user of a resource.
  If the resource is currently linked to a different user the old link is removed.
  If the linkedUser in the input is null, no new link is created.
  If the linkedUser is currently linked to a different resource the old link is removed.
  Since this operation crosses an eventual consistent boundary, this mutation does not verify that the supplied resource actually exists.
  """
  resourceUpdateLinkedUser(input: ResourceUpdateLinkedUserInput!): ResourceUpdateLinkedUserPayload!
  resourceAvatarUpdate(input: ResourceAvatarUpdateInput!): ResourceAvatarUpdatePayload!
  resourceAvatarDelete(input: ResourceAvatarDeleteInput!): ResourceAvatarDeletePayload!
  userCreate(input: UserCreateInput!): UserCreatePayload!
  userChangeActivationState(input: UserChangeActivationStateInput!): UserChangeActivationStatePayload!
  userReinvite(input: UserReinviteInput!): UserReinvitePayload!
  userGroupUpdate(input: UserGroupUpdateInput!): UserGroupUpdatePayload!
  userGroupCreate(input: UserGroupCreateInput!): UserGroupCreatePayload!
  userGroupDelete(input: UserGroupDeleteInput!): UserGroupDeletePayload!
  userAvatarUpdate(input: UserAvatarUpdateInput!): UserAvatarUpdatePayload!
  userAvatarDelete(input: UserAvatarDeleteInput!): UserAvatarDeletePayload!
  loginNoticeUpdate(input: LoginNoticeUpdateInput!): LoginNoticeUpdatePayload!
  inactivityTimeoutUpdate(input: InactivityTimeoutUpdateInput!): InactivityTimeoutUpdatePayload!
  sandboxUpdate: SandboxUpdatePayload
  sandboxDelete: SandboxDeletePayload
  actualsCreateOrUpdate(input: ActualsCreateOrUpdateInput!): ActualsCreateOrUpdatePayload!
  actualTimeWorkedDelete(input: ActualTimeWorkedDeleteInput!): ActualTimeWorkedDeletePayload!
  actualTimeWorkedDeleteAll(input: ActualTimeWorkedDeleteAllInput!): ActualTimeWorkedDeleteAllPayload!
  actualFinancialEventsCreateOrUpdate(input: ActualFinancialEventsCreateOrUpdateInput!): ActualFinancialEventsCreateOrUpdatePayload!
  actualFinancialEventsDelete(input: ActualFinancialEventsDeleteInput!): ActualFinancialEventsDeletePayload!
  actualFinancialEventEdit(input: ActualFinancialEventEditInput!): ActualFinancialEventEditPayload!
}
type MySettings {
  id: ID!
  userName: String!
  compareToScenario: Scenario
  compareToScenarioHistory: [Scenario!]!
  weekDisplayUnit: WeekDisplayUnit!
  """
  The scenario field in MySettings should only be used to query for showing the configuration.
  If you want to load projects, allocations, resources and the like from the users current scenario in a microfrontend,
  use Query.scenario with the provided scenario id instead. This ensures consistency within the application.
  """
  scenario: Scenario!
  scenarioHistory: [Scenario!]!
  portfolio: Portfolio
  portfolioHistory: [Portfolio!]!
  assignedScenarios: [Scenario!]!
  dateRangeConfiguration: DateRangeConfiguration!
  derivedDateRange: Period!
  workloadUnit: WorkloadUnit!
  zoomLevel: PortfolioDesignerZoomLevel!
  allocationMode: AllocationMode!
  projectEditTip: ProjectEditTip!
}
type MySettingsUpdateWeekDisplayUnitPayload {
  mySettings: MySettings!
}
type NotificationSettings {
  id: ID!
  projectManagerEmailSchedule: ProjectManagerEmailNotificationSchedule!
  projectManagerEmailEnabled: Boolean!
  resourceManagerEmailSchedule: ResourceManagerEmailNotificationSchedule!
  resourceManagerEmailEnabled: Boolean!
}
type NotificationSettingsProjectManagerEmailEnabledUpdatePayload {
  notificationSettings: NotificationSettings!
}
type NotificationSettingsProjectManagerEmailScheduleUpdatePayload {
  notificationSettings: NotificationSettings!
}
type NotificationSettingsResourceManagerEmailEnabledUpdatePayload {
  notificationSettings: NotificationSettings!
}
type NotificationSettingsResourceManagerEmailScheduleUpdatePayload {
  notificationSettings: NotificationSettings!
}
type ObsReferenceField {
  obsReferenceFieldDefinition: ObsReferenceFieldDefinition!
  obsReferenceValue: ObsUnit
}
type ObsReferenceFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  obsType: ObsType!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type ObsType {
  id: ID!
  name: String!
  obsUnits: [ObsUnit!]!
}
type ObsTypeCreatePayload {
  userError: ObsTypeCreateUserError
  obsType: ObsType
}
type ObsTypeCreateUserError {
  message: String!
  type: ObsTypeCreateErrorType!
  path: [String!]!
}
type ObsTypeDeletePayload {
  userError: ObsTypeDeleteUserError
}
type ObsTypeDeleteUserError {
  message: String!
  type: ObsTypeDeleteErrorType!
  path: [String!]!
}
type ObsTypeUpdateNamePayload {
  userError: ObsTypeUpdateNameUserError
  obsType: ObsType
}
type ObsTypeUpdateNameUserError {
  message: String!
  type: ObsTypeUpdateNameErrorType!
  path: [String!]!
}
type ObsUnit {
  id: ID!
  name: String!
  pathFromRoot: [ObsUnit!]!
  obsType: ObsType!
}
type ObsUnitCreatePayload {
  userError: ObsUnitCreateUserError
  obsUnit: ObsUnit
}
type ObsUnitCreateUserError {
  message: String!
  type: ObsUnitCreateErrorType!
  path: [String!]!
}
type ObsUnitDeletePayload {
  userError: ObsUnitDeleteUserError
}
type ObsUnitDeleteUserError {
  message: String!
  type: ObsUnitDeleteErrorType!
  path: [String!]!
}
type ObsUnitEmpty {
  _: Boolean
}
type ObsUnitFindOrCreatePayload {
  userError: ObsUnitFindOrCreateUserError
  obsUnit: ObsUnit
}
type ObsUnitFindOrCreateUserError {
  message: String!
  type: ObsUnitFindOrCreateErrorType!
  path: [String!]!
}
type ObsUnitUpdateNamePayload {
  userError: ObsUnitUpdateNameUserError
  obsUnit: ObsUnit
}
type ObsUnitUpdateNameUserError {
  message: String!
  type: ObsUnitUpdateNameErrorType!
  path: [String!]!
}
type ObsUnitUpdateParentError {
  message: String!
  type: ObsUnitUpdateParentErrorType!
  path: [String!]!
}
type ObsUnitUpdateParentPayload {
  userError: ObsUnitUpdateParentError
  obsType: ObsType
}
type OnboardingData {
  id: ID!
  centerVisible: Boolean!
  completedSteps: [String!]!
  selectedUseCase: String
  onboardingRole: OnboardingRole
}
type OnboardingDialog {
  staticFileBaseUrl: String!
  onboardingDialogsVisible: Boolean!
}
type OnboardingFlag {
  id: ID!
  value: Boolean!
}
type OnboardingFlagPayload {
  data: OnboardingFlag
  errors: [OnboardingFlagUpdateError!]!
}
type OnboardingOtter {
  baseUrlExternal: String!
}
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}
type PastePanda {
  baseUrlExternal: String!
}
type Period {
  start: ISO8601Date!
  finish: ISO8601Date!
}
type PipelinePunkupine {
  baseUrlExternal: String!
}
type PivotParrot {
  baseUrlExternal: String!
}
type PlanOfRecord implements Scenario {
  id: ID!
  legacyId: Int!
  name: String!
  projectSchedule(projectId: ID!): ProjectSchedule
  "first outside [0,500] returns INVALID_INPUT error"
  priorities(first: Int!, after: String): PrioritiesConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  projectSchedules(first: Int!, after: String, filter: ProjectFilterInput, sorting: ProjectScheduleSortingInput): ProjectScheduleConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  programSchedules(first: Int!, after: String): ProgramScheduleConnection!
  roleCapacities(filter: RoleCapacitiesFilterInput): [RoleCapacity!]!
  "first outside [0,500] returns INVALID_INPUT error"
  milestoneScheduleDependencies(first: Int!, after: String): MilestoneScheduleDependencyConnection!
  milestoneSchedules(filter: MilestoneSchedulesFilterInput): [MilestoneSchedule!]!
  "first outside [0,500] returns INVALID_INPUT error"
  allocations(first: Int!, after: String, filter: ScenarioAllocationFilterInput!): AllocationConnection!
  readOnly: Boolean!
}
type Portfolio {
  id: ID!
  name: String!
  publicAccess: Boolean!
}
type PortfolioChangeLogRecordConnection {
  edges: [PortfolioChangeLogRecordEdge!]!
  pageInfo: PageInfo!
}
type PortfolioChangeLogRecordEdge {
  cursor: String!
  node: ChangeLogRecord!
}
type PostalAddress {
  city: String
  country: String
  postalCode: String
}
type PrioritiesConnection {
  edges: [PrioritiesEdge!]!
  pageInfo: PageInfo!
}
type PrioritiesEdge {
  cursor: String!
  node: Priority!
}
type PrioritiesRankIntoRankCategoryPayload {
  userError: PrioritiesRankIntoRankCategoryUserError
  scenario: Scenario
}
type PrioritiesRankIntoRankCategoryUserError {
  message: String!
  type: PrioritiesRankIntoRankCategoryErrorType!
  path: [String!]!
}
type Program {
  id: ID!
  name: String!
}
type ProgramChangeLogRecord implements ChangeLogRecord {
  id: ID!
  program: Program
  changedBy: ChangeLogChangedBy
  timestamp: ISO8601DateTime!
  change: ProgramChangeLogChange
}
type ProgramChangeLogRecordConnection {
  edges: [ProgramChangeLogRecordEdge!]!
  pageInfo: ForwardPageInfo!
}
type ProgramChangeLogRecordEdge {
  cursor: String!
  node: ProgramChangeLogRecord!
}
type ProgramSchedule {
  id: ID!
  program: Program!
  scenario: Scenario!
  associatedProjectSchedules: [ProjectSchedule!]!
  rankCategory: RankCategory!
}
type ProgramScheduleConnection {
  edges: [ProgramScheduleEdge!]!
  pageInfo: PageInfo!
}
type ProgramScheduleCreatePayload {
  userError: ProgramScheduleCreateUserError
  programSchedule: ProgramSchedule
}
type ProgramScheduleCreateUserError {
  message: String!
  type: ProgramScheduleCreateErrorType!
  path: [String!]!
}
type ProgramScheduleDeletePayload {
  userError: ProgramScheduleDeleteUserError
}
type ProgramScheduleDeleteUserError {
  message: String!
  type: ProgramScheduleDeleteErrorType!
  path: [String!]!
}
type ProgramScheduleDuplicatePayload {
  userError: ProgramScheduleDuplicateUserError
  programSchedule: ProgramSchedule
}
type ProgramScheduleDuplicateUserError {
  message: String!
  type: ProgramScheduleDuplicateErrorType!
  path: [String!]!
}
type ProgramScheduleEdge {
  cursor: String!
  node: ProgramSchedule!
}
type ProgramScheduleEmpty {
  _: String
}
type ProgramSchedulePriority {
  programSchedule: ProgramSchedule!
}
type ProgramScheduleRankByScorePayload {
  userError: ProgramScheduleRankByScoreUserError
  scenario: Scenario
}
type ProgramScheduleRankByScoreUserError {
  message: String!
  type: ProgramScheduleRankByScoreErrorType!
  path: [String!]!
}
type ProgramScheduleRankRelativeToProgramSchedulePayload {
  userError: ProgramScheduleRankRelativeToProgramScheduleUserError
  programSchedule: ProgramSchedule
}
type ProgramScheduleRankRelativeToProgramScheduleUserError {
  message: String!
  type: ProgramScheduleRankRelativeToProgramScheduleErrorType!
  path: [String!]!
}
type ProgramScheduleRankRelativeToProjectSchedulePayload {
  userError: ProgramScheduleRankRelativeToProjectScheduleUserError
  programSchedule: ProgramSchedule
}
type ProgramScheduleRankRelativeToProjectScheduleUserError {
  message: String!
  type: ProgramScheduleRankRelativeToProjectScheduleErrorType!
  path: [String!]!
}
type ProgramScheduleReferenceField {
  programScheduleReferenceFieldDefinition: ProgramScheduleReferenceFieldDefinition!
  programScheduleReferenceValue: ProgramSchedule
}
type ProgramScheduleReferenceFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type ProgramUpdateNamePayload {
  program: Program
  userError: ProgramUpdateNameUserError
}
type ProgramUpdateNameUserError {
  message: String!
  type: ProgramUpdateNameErrorType!
  path: [String!]!
}
type Project {
  id: ID!
  externalId: String!
  "Missing read permission for this field returns USER_RIGHT_MISSING error"
  projectKey: String
  name: String!
  notes: String
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costType: CostType
  manager: Resource
  "Missing read permission for this field returns USER_RIGHT_MISSING error"
  status: LookupField
  fields(ids: [ID!]!): [ProjectField!]!
  businessGoal: BusinessGoal
  obsUnits: [ObsUnit!]!
  "Missing license for PROJECT_SCORE feature returns 0"
  score: Int!
  "Missing read permission for this field returns USER_RIGHT_MISSING error"
  approvedTotalEffort: DecimalField
  "Missing read permission for this field returns USER_RIGHT_MISSING error"
  approvedCapExBudget: DecimalField
  "Missing read permission for this field returns USER_RIGHT_MISSING error"
  approvedOpExBudget: DecimalField
  isInPortfolio(portfolioId: ID!): Boolean!
  projectSchedules: [ProjectSchedule!]!
  jiraProjectLink: JiraProjectLink
  comments(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String  ): ProjectCommentConnection
  "The permission READ_ACTUAL_TIME_WORKED is required."
  actualTimeWorked: ProjectActualTimeWorked
  "The permission READ_ACTUAL_TIME_WORKED and ACCESS_FINANCIAL_DATA is required."
  actualFinancialEvents: ProjectActualFinancialEvents
}
type ProjectActualFinancialEvents {
  project: Project
  totalCost: Float
  totalCostCapEx: Float
  totalCostOpEx: Float
  totalBenefit: Float
  lastBookingDate: ISO8601Date
  entries(filter: ActualFinancialEventEntitiesFilterInput): [ActualFinancialEvent!]!
}
type ProjectActualTimeWorked {
  project: Project
  totalHours: Float
  lastBookingDate: ISO8601Date
  lastUpdated: ISO8601DateTime
  "ACCESS_FINANCIAL_DATA permission is required"
  totalCostCapEx: Float
  "ACCESS_FINANCIAL_DATA permission is required"
  totalCostOpEx: Float
  "The permission READ_ACTUAL_TIME_WORKED is required."
  entries(
    "Only values between 1 and 100 are valid."
    first: Int,after: String, filter: ActualTimeWorkedFilterInput  ): ActualTimeWorkedByEntityConnection
}
type ProjectChangeLogRecord implements ChangeLogRecord {
  id: ID!
  "Can be null, when the project was deleted. (resolved via Federation)"
  project: Project
  changedBy: ChangeLogChangedBy
  timestamp: ISO8601DateTime!
  change: ProjectChangeLogChange
}
type ProjectChangeLogRecordConnection {
  edges: [ProjectChangeLogRecordEdge!]!
  pageInfo: ForwardPageInfo!
}
type ProjectChangeLogRecordEdge {
  cursor: String!
  node: ProjectChangeLogRecord!
}
type ProjectComment {
  id: ID!
  scenario: Scenario
  planOfRecord: Scenario
  author: User
  timestamp: ISO8601DateTime!
  text: String!
  isDeleted: Boolean!
}
type ProjectCommentConnection {
  edges: [ProjectCommentEdge!]!
  pageInfo: ProjectCommentConnectionPageInfo!
}
type ProjectCommentConnectionPageInfo {
  hasNextPage: Boolean!
  endCursor: String
}
type ProjectCommentCreateError {
  message: String!
  type: ProjectCommentCreateErrorType!
  path: [String!]!
}
type ProjectCommentCreatePayload {
  comment: ProjectComment
  userError: ProjectCommentCreateError
}
type ProjectCommentDeletePayload {
  comment: ProjectComment
  userError: ProjectCommentDeleteUserError
}
type ProjectCommentDeleteUserError {
  message: String!
  path: [String!]!
  type: ProjectCommentDeleteUserErrorType!
}
type ProjectCommentEdge {
  cursor: String!
  node: ProjectComment!
}
type ProjectConnection {
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}
type ProjectCreateGenericPayload {
  userError: ProjectCreateGenericUserError
  projectSchedule: ProjectSchedule
}
type ProjectCreateGenericUserError {
  message: String!
  type: ProjectCreateGenericErrorType!
  path: [String!]!
  fieldDefinitionId: String
}
type ProjectCreatePayload {
  userError: ProjectCreateUserError
  projectSchedule: ProjectSchedule
}
type ProjectCreateUserError {
  message: String!
  type: ProjectCreateUserErrorType!
  path: [String!]!
}
type ProjectDateFinance implements ProjectFinance {
  id: ID!
  value: Float!
  type: FinanceType!
  description: String
  financeCategory: FinanceCategory
  date: ISO8601Date!
}
type ProjectDateFinanceCreatePayload {
  userError: ProjectDateFinanceCreateUserError
  projectFinance: ProjectDateFinance
}
type ProjectDateFinanceCreateUserError {
  message: String!
  type: ProjectDateFinanceCreateErrorType!
  path: [String!]!
}
type ProjectEdge {
  cursor: String!
  node: Project!
}
type ProjectEditTip {
  acknowledged: Boolean!
}
type ProjectFinanceDeletePayload {
  userError: ProjectFinanceDeleteUserError
}
type ProjectFinanceDeleteUserError {
  message: String!
  type: ProjectFinanceDeleteErrorType!
  path: [String!]!
}
type ProjectFinanceMoveToDatePayload {
  userError: ProjectFinanceMoveToDateUserError
  projectFinance: ProjectDateFinance
}
type ProjectFinanceMoveToDateUserError {
  message: String!
  type: ProjectFinanceMoveToDateErrorType!
  path: [String!]!
}
type ProjectFinanceMoveToMilestonePayload {
  userError: ProjectFinanceMoveToMilestoneUserError
  projectFinance: ProjectMilestoneFinance
}
type ProjectFinanceMoveToMilestoneUserError {
  message: String!
  type: ProjectFinanceMoveToMilestoneErrorType!
  path: [String!]!
}
type ProjectFinanceMoveToProjectFinishPayload {
  userError: ProjectFinanceMoveToProjectFinishUserError
  projectFinance: ProjectFinishFinance
}
type ProjectFinanceMoveToProjectFinishUserError {
  message: String!
  type: ProjectFinanceMoveToProjectFinishErrorType!
  path: [String!]!
}
type ProjectFinanceMoveToProjectStartPayload {
  userError: ProjectFinanceMoveToProjectStartUserError
  projectFinance: ProjectStartFinance
}
type ProjectFinanceMoveToProjectStartUserError {
  message: String!
  type: ProjectFinanceMoveToProjectStartErrorType!
  path: [String!]!
}
type ProjectFinanceUpdateDescriptionPayload {
  userError: ProjectFinanceUpdateDescriptionUserError
  projectFinance: ProjectFinance
}
type ProjectFinanceUpdateDescriptionUserError {
  message: String!
  type: ProjectFinanceUpdateDescriptionErrorType!
  path: [String!]!
}
type ProjectFinanceUpdateFinanceCategoryPayload {
  userError: ProjectFinanceUpdateFinanceCategoryUserError
  projectFinance: ProjectFinance
}
type ProjectFinanceUpdateFinanceCategoryUserError {
  message: String!
  type: ProjectFinanceUpdateFinanceCategoryErrorType!
  path: [String!]!
}
type ProjectFinanceUpdateTypePayload {
  userError: ProjectFinanceUpdateTypeUserError
  projectFinance: ProjectFinance
}
type ProjectFinanceUpdateTypeUserError {
  message: String!
  type: ProjectFinanceUpdateTypeErrorType!
  path: [String!]!
}
type ProjectFinanceUpdateValuePayload {
  userError: ProjectFinanceUpdateValueUserError
  projectFinance: ProjectFinance
}
type ProjectFinanceUpdateValueUserError {
  message: String!
  type: ProjectFinanceUpdateValueErrorType!
  path: [String!]!
}
type ProjectFinishFinance implements ProjectFinance {
  id: ID!
  value: Float!
  type: FinanceType!
  description: String
  financeCategory: FinanceCategory
  projectSchedule: ProjectSchedule!
  date: ISO8601Date!
}
type ProjectFinishFinanceCreatePayload {
  userError: ProjectFinishFinanceCreateUserError
  projectFinance: ProjectFinishFinance
}
type ProjectFinishFinanceCreateUserError {
  message: String!
  type: ProjectFinishFinanceCreateErrorType!
  path: [String!]!
}
type ProjectMilestoneFinance implements ProjectFinance {
  id: ID!
  value: Float!
  type: FinanceType!
  description: String
  financeCategory: FinanceCategory
  milestoneSchedule: MilestoneSchedule!
  date: ISO8601Date!
}
type ProjectMilestoneFinanceCreatePayload {
  userError: ProjectMilestoneFinanceCreateUserError
  projectFinance: ProjectMilestoneFinance
}
type ProjectMilestoneFinanceCreateUserError {
  message: String!
  type: ProjectMilestoneFinanceCreateErrorType!
  path: [String!]!
}
type ProjectOverviewConfiguration {
  "The database uuid of the configuration"
  id: ID
  selectedFields: [ProjectOverviewSelectedField!]!
}
type ProjectOverviewConfigurationSavePayload {
  projectOverviewConfiguration: ProjectOverviewConfiguration
  userError: ProjectOverviewSaveConfigurationUserError
}
type ProjectOverviewSaveConfigurationUserError {
  message: String!
  type: ProjectOverviewConfigurationSaveErrorType!
  path: [String!]!
}
type ProjectOverviewSelectedField {
  id: String!
  type: ProjectOverviewConfigurationFieldType!
}
type ProjectPhase {
  id: ID!
  externalId: String!
  name: String!
  color: HexColorCode
}
type ProjectPhaseEmpty {
  _: Boolean
}
type ProjectSchedule {
  id: ID!
  project: Project!
  scenario: Scenario!
  period: Period!
  milestoneSchedules: [MilestoneSchedule!]!
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  finances: [ProjectFinance!]
  allocations: [Allocation!]!
  programSchedule: ProgramSchedule
  """
  In general a KPI becomes 0.0 when its terms sum up to zero and `null` when any of its terms cannot be calculated or when required permissions are missing,
  e.g. pastFinancialCosts becomes `null` when there are no finances in the relevant period to sum up, totalAllocationValueInHours becomes `null` when no
  roles or resources are allocated but 0.0 when roles or resources are allocated without value.
  Required permissions and exceptions to these general rules are documented at the KPIs themselves.
  """
  kpis: ProjectScheduleKPIs!
  rankCategory: RankCategory!
  fields(ids: [ID!]!): [ProjectScheduleField!]!
  "If a project is read only, all modification attempts to this project will fail. If it is not read only, further permissions may be required for modifications"
  readOnly: Boolean!
}
type ProjectScheduleChangeDateField {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: DateFieldDefinition
  changedFrom: ISO8601Date
  changedTo: ISO8601Date
}
type ProjectScheduleChangeProgramField {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: ProgramScheduleReferenceFieldDefinition
  "Can be null, when the programSchedule was deleted. (resolved via Federation)"
  changedFrom: ProgramScheduleResult
  "Can be null, when the programSchedule was deleted. (resolved via Federation)"
  changedTo: ProgramScheduleResult
}
type ProjectScheduleChangeRankCategoryField {
  "Can be null, when the field was deleted. (resolved via Federation)"
  fieldDefinition: RankCategoryFieldDefinition
  changedFrom: RankCategory
  changedTo: RankCategory
}
type ProjectScheduleConnection {
  edges: [ProjectScheduleEdge!]!
  pageInfo: PageInfo!
  "Maximum rank of all project schedules within the scenario, depending on the specified scenario, portfolio and period"
  maxRank: Int
  "Total amount of project schedules within the scenario, depending on the specified filters"
  totalEdges: Int!
}
type ProjectScheduleDeletePayload {
  userError: ProjectScheduleDeleteUserError
}
type ProjectScheduleDeleteUserError {
  message: String!
  type: ProjectScheduleDeleteErrorType!
  path: [String!]!
}
type ProjectScheduleDuplicatePayload {
  userError: ProjectScheduleDuplicateUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleDuplicateUserError {
  message: String!
  type: ProjectScheduleDuplicateErrorType!
  path: [String!]!
}
type ProjectScheduleEdge {
  cursor: String!
  node: ProjectSchedule!
  "Current rank of the project schedule within the scenario, depending on the specified project filters"
  rank: Int!
  "Ideal rank of the project schedule within the scenario based on its score, depending on the specified project filters"
  destinationRank: Int
}
type ProjectScheduleExtendAllocationsPayload {
  userError: ProjectScheduleExtendAllocationsUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleExtendAllocationsUserError {
  message: String!
  type: ProjectScheduleExtendAllocationsErrorType!
  path: [String!]!
}
type ProjectScheduleInsertBreakPayload {
  userError: ProjectScheduleInsertBreakUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleInsertBreakUserError {
  message: String!
  type: ProjectScheduleInsertBreakErrorType!
  path: [String!]!
}
type ProjectScheduleKPIs {
  projectSchedule: ProjectSchedule!
  "aka `Planned Allocations`"
  totalAllocationValueInHours: Float
  """
  aka `Planned Benefit`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalBenefit: Float
  """
  aka `Costs Total`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalCost: Float
  """
  aka `Net Value`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalNetValue: Float
  """
  aka `Planned CapEx`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalCostCapex: Float
  """
  aka `Planned OpEx`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalCostOpex: Float
  """
  aka `Planned Allocation Costs`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalCostAllocations: Float
  """
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  Becomes 0.0 (not `null`) for already completed project schedules with allocations
  """
  futureAllocationCosts: Float
  """
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  Becomes 0.0 (not `null`) for not yet started project schedules with allocations
  """
  pastAllocationCosts: Float
  """
  aka `Planned Financial Events Costs`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  totalCostFinancials: Float
  """
  aka `Past Financial Events Costs
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  pastFinancialCosts: Float
  """
  aka `Future Financial Events Costs`
  Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error
  """
  futureFinancialCosts: Float
  "Becomes 0.0 (not `null`) for already completed project schedules with allocations"
  plannedAllocationsUntilToday: Float
  "Becomes 0.0 (not `null`) for not yet started project schedules with allocations"
  remainingAllocationsFromToday: Float
  "Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error"
  plannedAllocationsUntilLastBookingDate: Float
  "Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error"
  remainingAllocationsFromLastBookingDate: Float
  "Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error"
  plannedAllocationsBetweenLastBookingDateAndToday: Float
  """
  aka `Allocation Estimate at Completion`
  Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error
  """
  estimatedTimeWorkedAtCompletion: Float
  """
  aka `Deviation of EAC from Approved Total Effort`
  Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error
  """
  deviationOfEstimateFromApprovedTotalEffort: Float
  """
  aka `Deviation of Allocation EAC from Approved Total Effort (in %)`
  Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error
  """
  deviationOfEstimateFromApprovedTotalEffortPercentage: Float
  """
  aka `Deviation of Actual Time Worked from Plan`
  Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error
  """
  deviationOfActualFromPlan: Float
  """
  aka `Deviation of Actual Time Worked from Plan (in %)`
  Missing READ_ACTUAL_TIME_WORKED permission returns USER_RIGHT_MISSING error
  """
  deviationOfActualFromPlanPercentage: Float
}
type ProjectScheduleMovePeriodPayload {
  userError: ProjectScheduleMovePeriodUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleMovePeriodUserError {
  message: String!
  type: ProjectScheduleMovePeriodErrorType!
  path: [String!]!
}
type ProjectSchedulePriority {
  projectSchedule: ProjectSchedule!
}
type ProjectScheduleRankByScorePayload {
  userError: ProjectScheduleRankByScoreUserError
  scenario: Scenario
}
type ProjectScheduleRankByScoreUserError {
  message: String!
  type: ProjectScheduleRankByScoreErrorType!
  path: [String!]!
}
type ProjectScheduleRankRelativeToProgramSchedulePayload {
  userError: ProjectScheduleRankRelativeToProgramScheduleUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleRankRelativeToProgramScheduleUserError {
  message: String!
  type: ProjectScheduleRankRelativeToProgramScheduleErrorType!
  path: [String!]!
}
type ProjectScheduleRankRelativeToProjectSchedulePayload {
  userError: ProjectScheduleRankRelativeToProjectScheduleUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleRankRelativeToProjectScheduleUserError {
  message: String!
  type: ProjectScheduleRankRelativeToProjectScheduleErrorType!
  path: [String!]!
}
type ProjectScheduleRemoveSectionPayload {
  userError: ProjectScheduleRemoveSectionUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleRemoveSectionUserError {
  message: String!
  type: ProjectScheduleRemoveSectionErrorType!
  path: [String!]!
}
type ProjectScheduleReplaceAllocationsPayload {
  userError: ProjectScheduleReplaceAllocationsUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleReplaceAllocationsUserError {
  message: String!
  type: ProjectScheduleReplaceAllocationsErrorType!
  path: [String!]!
}
type ProjectScheduleSplitAllocationsAtDatePayload {
  userError: ProjectScheduleSplitAllocationsAtDateUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleSplitAllocationsAtDateUserError {
  message: String!
  type: ProjectScheduleSplitAllocationsAtDateErrorType!
  path: [String!]!
}
type ProjectScheduleSubmitToScenarioPayload {
  userError: ProjectScheduleSubmitToScenarioUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleSubmitToScenarioUserError {
  message: String!
  type: ProjectScheduleSubmitToScenarioErrorType!
  path: [String!]!
}
type ProjectScheduleUpdateDurationPayload {
  userError: ProjectScheduleUpdateDurationUserError
  projectSchedule: ProjectSchedule
}
type ProjectScheduleUpdateDurationUserError {
  message: String!
  type: ProjectScheduleUpdateDurationErrorType!
  path: [String!]!
}
type ProjectStartFinance implements ProjectFinance {
  id: ID!
  value: Float!
  type: FinanceType!
  description: String
  financeCategory: FinanceCategory
  projectSchedule: ProjectSchedule!
  date: ISO8601Date!
}
type ProjectStartFinanceCreatePayload {
  userError: ProjectStartFinanceCreateUserError
  projectFinance: ProjectStartFinance
}
type ProjectStartFinanceCreateUserError {
  message: String!
  type: ProjectStartFinanceCreateErrorType!
  path: [String!]!
}
type ProjectUpdateFieldsPayload {
  userError: ProjectUpdateFieldsUserError
  project: Project
}
type ProjectUpdateFieldsUserError {
  message: String!
  type: ProjectUpdateFieldsErrorType!
  path: [String!]!
  fieldDefinitionId: String
}
type ProjectViewConfiguration {
  sections: [ProjectViewConfigurationSection!]
  availableSectionTypes: [ProjectViewConfigurationSectionType!]!
}
type ProjectViewConfigurationField {
  id: ID!
  fieldId: String!
  fieldType: ProjectViewConfigurationFieldType!
}
type ProjectViewConfigurationSavePayload {
  userErrors: [ProjectViewConfigurationSaveUserError!]
  projectViewConfiguration: ProjectViewConfiguration
}
type ProjectViewConfigurationSaveUserError {
  message: String!
  type: ProjectViewConfigurationSaveErrorType!
  path: [String!]!
}
type ProjectViewConfigurationSection {
  id: ID!
  type: ProjectViewConfigurationSectionType!
  name: String
  fields: [ProjectViewConfigurationField!]
}
type ProjectViewConfigurationStartFinishField {
  id: ID!
  projectScheduleStartFieldId: String!
  projectScheduleFinishFieldId: String!
  fieldType: ProjectViewConfigurationFieldType!
  mandatory: Boolean!
}
type PushPiranha {
  baseUrlExternal: String!
}
type Query {
  """
  Get all webhooks within customers' Meisterplan system as a paginated list.
  Requires user permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS.
  """
  webhooks(first: Int!, after: String): WebhookConnection!
  """
  Get one webhook within customers' Meisterplan system by its id.
  Requires user permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS.
  """
  webhook(id: ID!): Webhook
  milestoneSchedule(id: ID!): MilestoneSchedule
  businessGoals: [BusinessGoal!]!
  calendar(id: ID!): Calendar
  calendars: [Calendar!]!
  defaultCalendar: Calendar!
  financeCategories: [FinanceCategory!]!
  instance: Instance!
  mySettings: MySettings!
  obsType(id: ID!): ObsType
  obsTypes: [ObsType!]!
  portfolios: [Portfolio!]!
  programSchedule(id: ID!): ProgramSchedule
  program(id: ID!): Program
  "first outside [0,500] returns INVALID_INPUT error"
  projects(first: Int!, after: String, filter: ProjectsFilterInput): ProjectConnection!
  projectSchedule(id: ID!): ProjectSchedule
  "This field is accessed by the historyhamster and maskedicebear service to service call which is not recorded by the apollo studio validation"
  projectFieldDefinitions: [FieldDefinition!]!
  projectScheduleFieldDefinitions: [FieldDefinition!]!
  projectPhases: [ProjectPhase!]!
  projectStatusFieldDefinition: LookupFieldDefinition
  resource(id: ID!): Resource
  "first outside [0,500] returns INVALID_INPUT error"
  resources(first: Int!, after: String, filter: ResourceFilterInput, sorting: ResourceSortingInput): ResourceConnection!
  role(id: ID!): Role
  "first outside [0,500] returns INVALID_INPUT error"
  roles(first: Int!, after: String, filter: RoleFilterInput, sorting: RoleSortingInput): RoleConnection!
  scenario(id: ID): Scenario
  scenarios(filter: ScenarioFilterInput): [Scenario!]!
  skills: [Skill!]!
  serviceDiscovery: ServiceDiscovery!
  "Demonstration test code only. Do not use productively in Meisterplan services."
  tigerBlogPost(id: ID!): TigerBlogPost
  "Demonstration test code only. Do not use productively in Meisterplan services."
  tigerBlogPosts(filter: TigerBlogPostFilter, 
    "Only values between 1 and 200 are valid."
    first: Int!,after: String  ): TigerBlogPostConnection!
  dummy: String @deprecated(reason: "Dummy query due to technical restrictions. Do not use.")
  myOnboardingData: OnboardingData!
  """
  Get the boolean state of an onboarding element (initially and during backend downtime `null`). Multiple flags can be
  retrieved at once by using GraphQL Aliasing.
  
  See onboardingFlagUpdate as well.
  """
  onboardingFlag(id: ID!): OnboardingFlag
  onboardingDialog: OnboardingDialog!
  projectViewConfiguration: ProjectViewConfiguration!
  projectViewConfigurationStartFinishField: ProjectViewConfigurationStartFinishField!
  projectOverviewConfiguration: ProjectOverviewConfiguration!
  noopMailMeerkat: Boolean @deprecated(reason: "No longer supported")
  jiraLinks: [JiraLink!]!
  jiraLink(id: ID!): JiraLink
  "The permission ACCESS_CHANGE_LOG is required."
  projectChangeLog(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String, filter: ProjectChangeLogFilterInput!  ): ProjectChangeLogRecordConnection
  "The permission ACCESS_CHANGE_LOG is required."
  programChangeLog(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String, filter: ProgramChangeLogFilterInput!  ): ProgramChangeLogRecordConnection
  "The permission ACCESS_CHANGE_LOG is required."
  portfolioChangeLog(
    "Only values between 0 and 100 are valid."
    last: Int!,
    """
    Backwards pagination is only supported in conjunction with last parameter. <br>
    Use before to get newer entries.
    """
    before: String,
    "Only values between 0 and 100 are valid."
    first: Int!,
    """
    Forward pagination is only supported in conjunction with first parameter. <br>
    Use after to get older entries.
    """
    after: String,filter: PortfolioChangeLogFilterInput!  ): PortfolioChangeLogRecordConnection
  "The permission ACCESS_CHANGE_LOG is required."
  resourceChangeLog(
    "Only values between 1 and 100 are valid."
    first: Int!,after: String, filter: ResourceChangeLogFilterInput!  ): ResourceChangeLogRecordConnection
  "The notification settings for notification schedules"
  notificationSettings: NotificationSettings
  viewConfigs(viewKey: ID!): ViewConfigList!
  "The notification settings for the comments"
  commentsNotificationSettings: CommentsNotificationSettings
  license: License
  users(
    "Only values between 1 and 200 are valid."
    first: Int!,
    "Provide a cursor to paginate. Only either 'after' or 'offset' can be used but NOT both."
    after: String,
    "Provide an offset to paginate. Only either 'after' or 'offset' can be used but NOT both."
    offset: Int,filter: UserFilterInput  ): UserConnection!
  user(id: ID!): User
  userGroups(
    "Only values between 1 and 200 are valid."
    first: Int!,
    "Provide a cursor to paginate. Only either 'after' or 'offset' can be used but NOT both."
    after: String,
    "Provide an offset to paginate. Only either 'after' or 'offset' can be used but NOT both."
    offset: Int,filter: UserGroupFilterInput  ): UserGroupConnection!
  userGroup(id: ID!): UserGroup
  authenticationSettings: AuthenticationSettings!
  inactivityTimeout: InactivityTimeout!
  sandbox: Sandbox
  noop: String @deprecated(reason: "ayeaye schema must contain a query type, don't call, dont'use, ignore")
}
type RankCategoryField {
  rankCategoryFieldDefinition: RankCategoryFieldDefinition!
  rankCategoryValue: RankCategory!
}
type RankCategoryFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type RegularScenario implements Scenario {
  id: ID!
  "legacy scenario ID for internal WebApp use only!"
  legacyId: Int!
  name: String!
  archived: Boolean!
  projectSchedule(projectId: ID!): ProjectSchedule
  "first outside [0,500] returns INVALID_INPUT error"
  priorities(first: Int!, after: String): PrioritiesConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  projectSchedules(first: Int!, after: String, filter: ProjectFilterInput, sorting: ProjectScheduleSortingInput): ProjectScheduleConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  programSchedules(first: Int!, after: String): ProgramScheduleConnection!
  roleCapacities(filter: RoleCapacitiesFilterInput): [RoleCapacity!]!
  "first outside [0,500] returns INVALID_INPUT error"
  milestoneScheduleDependencies(first: Int!, after: String): MilestoneScheduleDependencyConnection!
  milestoneSchedules(filter: MilestoneSchedulesFilterInput): [MilestoneSchedule!]!
  "first outside [0,500] returns INVALID_INPUT error"
  allocations(first: Int!, after: String, filter: ScenarioAllocationFilterInput!): AllocationConnection!
  readOnly: Boolean!
  assignedUsers: [User]!
}
type RemovedPeriod {
  start: ISO8601Date
  end: ISO8601Date
}
type Resource {
  id: ID!
  externalId: String
  resourceKey: String!
  firstName: String
  lastName: String!
  initials: String!
  displayName: String!
  manager: Resource
  emailAddress: String
  postalAddress: PostalAddress!
  employmentPeriod: EmploymentPeriod!
  resourceStatus: ResourceStatus!
  external: Boolean!
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costPerHour: Float
  primaryRole: Role
  calendar: Calendar!
  obsUnits: [ObsUnit!]!
  skills: [Skill!]!
  calendarDeviations: [CalendarDeviation!]!
  "Allocations of the resource on projects above the Cut-Off line"
  allocations(filter: AllocationFilterInput!): [ResourceAllocation!]!
  absences(filter: ResourceAbsenceFilterInput): [ResourceAbsence!]!
  isInPortfolio(portfolioId: ID!): Boolean!
  """
  Capacities are sliced to fit a time grid according to the selected aggregation.
  A maximum of 4000 slices will be returned.
  """
  capacitySlices(filter: ResourceCapacitySlicesFilterInput!, aggregation: Aggregation!): [CapacitySlice!]!
  """
  Absences are sliced to fit a time grid according to the selected aggregation.
  A maximum of 4000 slices will be returned. We do not return slices with value 0.
  """
  absenceSlices(filter: AbsenceSliceFilterInput!, aggregation: Aggregation!): [AbsenceSlice!]!
  """
  Allocations are sliced to fit a time grid according to the selected aggregation.
  Only includes slices of project allocations that are above the cut-off line.
  A maximum of 4000 slices will be returned. We do not return slices with value 0.
  """
  allocationSlices(filter: ResourceAllocationSlicesFilterInput!, aggregation: Aggregation!): [AggregatedAllocationSlice!]!
  linkedUser: User
  avatar: ResourceAvatar
}
type ResourceAbsence {
  id: ID!
  start: ISO8601Date!
  end: ISO8601Date!
  startType: AbsenceDayType!
  endType: AbsenceDayType!
}
type ResourceAbsencesCreatePayload {
  userError: ResourceAbsencesCreateUserError
  createdAbsences: [ResourceAbsence!]!
  resource: Resource
}
type ResourceAbsencesCreateUserError {
  message: String!
  type: ResourceAbsencesCreateErrorType!
  path: [String!]!
}
type ResourceAbsencesDeletePayload {
  userError: ResourceAbsencesDeleteUserError
  resource: Resource
}
type ResourceAbsencesDeleteUserError {
  message: String!
  type: ResourceAbsencesDeleteErrorType!
  path: [String!]!
}
type ResourceAbsencesUpdatePayload {
  userError: ResourceAbsencesUpdateUserError
  updatedAbsences: [ResourceAbsence!]!
  resource: Resource
}
type ResourceAbsencesUpdateUserError {
  message: String!
  type: ResourceAbsencesUpdateErrorType!
  path: [String!]!
}
type ResourceAllocation implements Allocation {
  projectSchedule: ProjectSchedule!
  resource: Resource!
  projectRole: Role
  segments: [AllocationSegment!]!
  kpis: AllocationKPIs!
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costType: CostType
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costPerHour: Float
  """
  Allocations are sliced to fit a time grid according to the selected aggregation.
  A maximum of 4000 slices will be returned. We do not return slices with value 0.
  """
  slices(aggregation: Aggregation!, filter: AllocationSliceFilterInput!): [AllocationSlice!]!
}
type ResourceAllocationCreateOrUpdatePayload {
  allocation: ResourceAllocation
  userError: ResourceAllocationCreateOrUpdateUserError
}
type ResourceAllocationCreateOrUpdateUserError {
  message: String!
  type: ResourceAllocationCreateOrUpdateErrorType!
  path: [String!]!
}
type ResourceAllocationCreatePayload {
  allocation: ResourceAllocation
  userError: ResourceAllocationCreateUserError
}
type ResourceAllocationCreateUserError {
  message: String!
  type: ResourceAllocationCreateErrorType!
  path: [String!]!
}
type ResourceAllocationDeletePayload {
  userError: ResourceAllocationDeleteUserError
}
type ResourceAllocationDeleteUserError {
  message: String!
  type: ResourceAllocationDeleteErrorType!
  path: [String!]!
}
type ResourceAllocationTransferToResourcePayload {
  targetAllocation: ResourceAllocation
  userError: ResourceAllocationTransferToResourceUserError
}
type ResourceAllocationTransferToResourceUserError {
  message: String!
  type: ResourceAllocationTransferToResourceErrorType!
  path: [String!]!
}
type ResourceAllocationUnstaffToProjectRolePayload {
  projectRoleAllocation: RoleAllocation
  userError: ResourceAllocationUnstaffToProjectRoleUserError
}
type ResourceAllocationUnstaffToProjectRoleUserError {
  message: String!
  type: ResourceAllocationUnstaffToProjectRoleErrorType!
  path: [String!]!
}
type ResourceAllocationUpdatePayload {
  allocation: ResourceAllocation
  userError: ResourceAllocationUpdateUserError
}
type ResourceAllocationUpdateUserError {
  message: String!
  type: ResourceAllocationUpdateErrorType!
  path: [String!]!
}
type ResourceAvatar {
  url: String!
}
type ResourceAvatarDeleteError {
  message: String!
  type: ResourceAvatarDeleteErrorType!
  path: [String!]!
}
type ResourceAvatarDeletePayload {
  resource: Resource
  userErrors: [ResourceAvatarDeleteError!]!
}
type ResourceAvatarUpdateError {
  message: String!
  type: ResourceAvatarUpdateErrorType!
  path: [String!]!
}
type ResourceAvatarUpdatePayload {
  resource: Resource
  userErrors: [ResourceAvatarUpdateError!]!
}
type ResourceChangeLogRecord {
  id: ID!
  changedBy: ChangeLogChangedBy
  timestamp: ISO8601DateTime!
  change: ResourceChangeLogChange
}
type ResourceChangeLogRecordConnection {
  edges: [ResourceChangeLogRecordEdge!]!
  pageInfo: ForwardPageInfo!
}
type ResourceChangeLogRecordEdge {
  cursor: String!
  node: ResourceChangeLogRecord!
}
type ResourceConnection {
  edges: [ResourceEdge!]!
  pageInfo: PageInfo!
  totalEdges: Int!
}
type ResourceCreatePayload {
  userError: ResourceCreateUserError
  resource: Resource
}
type ResourceCreateUserError {
  message: String!
  type: ResourceCreateErrorType!
  path: [String!]!
}
type ResourceDeletePayload {
  userError: ResourceDeleteUserError
}
type ResourceDeleteUserError {
  message: String!
  type: ResourceDeleteErrorType!
  path: [String!]!
}
type ResourceEdge {
  cursor: String!
  node: Resource!
}
type ResourceEmpty {
  _: Boolean
}
type ResourceKeyGeneratePayload {
  resourceKey: String!
}
type ResourceReferenceField {
  resourceReferenceFieldDefinition: ResourceReferenceFieldDefinition!
  resourceReferenceValue: Resource
}
type ResourceReferenceFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type ResourceRoadrunner {
  baseUrlExternal: String!
}
type ResourceUpdateCalendarDeviationsPayload {
  userError: ResourceUpdateCalendarDeviationsUserError
  resource: Resource
}
type ResourceUpdateCalendarDeviationsUserError {
  message: String!
  type: ResourceUpdateCalendarDeviationsErrorType!
  path: [String!]!
}
type ResourceUpdateLinkedUserError {
  message: String!
  type: ResourceUpdateLinkedUserErrorType!
  path: [String!]!
}
type ResourceUpdateLinkedUserPayload {
  changedUsers: [User!]
  userErrors: [ResourceUpdateLinkedUserError!]!
}
type ResourceUpdatePayload {
  userError: ResourceUpdateUserError
  resource: Resource
}
type ResourceUpdateUserError {
  message: String!
  type: ResourceUpdateErrorType!
  path: [String!]!
}
type RoadmapRaven {
  baseUrlExternal: String!
}
type Role {
  id: ID!
  externalId: String
  name: String!
  manager: Resource
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costType: CostType
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costPerHour: Float
  obsUnits: [ObsUnit!]!
  "Allocations of the role on projects above the Cut-Off line"
  allocations(filter: AllocationFilterInput!): [RoleAllocation!]!
  capacity(scenarioId: ID!): RoleCapacity
  isInPortfolio(portfolioId: ID!): Boolean!
  """
  Capacities are sliced to fit a time grid according to the selected aggregation.
  Role capacity slices can be negative.
  A maximum of 4000 slices will be returned.
  """
  capacitySlices(filter: RoleCapacitySlicesFilterInput!, aggregation: Aggregation!): [CapacitySlice!]!
  """
  Allocations are sliced to fit a time grid according to the selected aggregation.
  Only includes slices of project allocations that are above the cut-off line.
  A maximum of 4000 slices will be returned. We do not return slices with value 0.
  """
  allocationSlices(filter: RoleAllocationSlicesFilterInput!, aggregation: Aggregation!): [AggregatedAllocationSlice!]!
  "Get the role velocity factor for this role and the given Jira Link."
  jiraLinkVelocityFactor(jiraLinkId: ID!): Float
}
type RoleAllocation implements Allocation {
  projectSchedule: ProjectSchedule!
  role: Role!
  segments: [AllocationSegment!]!
  kpis: AllocationKPIs!
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costType: CostType
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costPerHour: Float
  """
  Allocations are sliced to fit a time grid according to the selected aggregation.
  A maximum of 4000 slices will be returned. We do not return slices with value 0.
  """
  slices(aggregation: Aggregation!, filter: AllocationSliceFilterInput!): [AllocationSlice!]!
}
type RoleAllocationCreateOrUpdatePayload {
  allocation: RoleAllocation
  userError: RoleAllocationCreateOrUpdateUserError
}
type RoleAllocationCreateOrUpdateUserError {
  message: String!
  type: RoleAllocationCreateOrUpdateErrorType!
  path: [String!]!
}
type RoleAllocationCreatePayload {
  allocation: RoleAllocation
  userError: RoleAllocationCreateUserError
}
type RoleAllocationCreateUserError {
  message: String!
  type: RoleAllocationCreateErrorType!
  path: [String!]!
}
type RoleAllocationDeletePayload {
  userError: RoleAllocationDeleteUserError
}
type RoleAllocationDeleteUserError {
  message: String!
  type: RoleAllocationDeleteErrorType!
  path: [String!]!
}
type RoleAllocationUpdatePayload {
  allocation: RoleAllocation
  userError: RoleAllocationUpdateUserError
}
type RoleAllocationUpdateUserError {
  message: String!
  type: RoleAllocationUpdateErrorType!
  path: [String!]!
}
type RoleCapacity {
  role: Role!
  deviations: [RoleCapacityDeviation!]!
}
type RoleCapacityDeviation {
  start: ISO8601Date
  end: ISO8601Date
  additionalCapacityInFTE: Float!
}
type RoleCapacityUpdateDeviationsPayload {
  roleCapacity: RoleCapacity
  userError: RoleCapacityUpdateDeviationsUserError
}
type RoleCapacityUpdateDeviationsUserError {
  message: String!
  type: RoleCapacityUpdateDeviationsErrorType!
  path: [String!]!
}
type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
  totalEdges: Int!
}
type RoleCreatePayload {
  userError: RoleCreateUserError
  role: Role
}
type RoleCreateUserError {
  message: String!
  type: RoleCreateErrorType!
  path: [String!]!
}
type RoleDeletePayload {
  userError: RoleDeleteUserError
}
type RoleDeleteUserError {
  message: String!
  type: RoleDeleteErrorType!
  path: [String!]!
}
type RoleEdge {
  cursor: String!
  node: Role!
}
type RoleUpdatePayload {
  userError: RoleUpdateUserError
  role: Role
}
type RoleUpdateUserError {
  message: String!
  type: RoleUpdateErrorType!
  path: [String!]!
}
type RollingDateRangeConfiguration {
  monthsBeforeCurrent: Int!
  monthsAfterCurrent: Int!
}
type Sandbox {
  systemUrl: String
  initiator: User
  lastUpdate: ISO8601DateTime!
  lifecycleState: SandboxLifecycleState!
}
type SandboxDeleteError {
  message: String!
  type: SandboxDeleteErrorType!
}
type SandboxDeletePayload {
  sandbox: Sandbox
  userError: SandboxDeleteError
}
type SandboxSandDollar {
  baseUrlExternal: String!
}
type SandboxUpdateError {
  message: String!
  type: SandboxUpdateErrorType!
}
type SandboxUpdatePayload {
  sandbox: Sandbox
  userError: SandboxUpdateError
}
type ScenarioCopyPayload {
  userError: ScenarioCopyUserError
  scenario: RegularScenario
}
type ScenarioCopyUserError {
  message: String!
  type: ScenarioCopyErrorType!
  path: [String!]!
}
type ScenarioDeletePayload {
  userError: ScenarioDeleteUserError
}
type ScenarioDeleteUserError {
  message: String!
  type: ScenarioDeleteErrorType!
  path: [String!]!
}
type ScenarioPrioritiesRankByProjectScorePayload {
  userError: ScenarioPrioritiesRankByProjectScoreUserError
  scenario: Scenario
}
type ScenarioPrioritiesRankByProjectScoreUserError {
  message: String!
  type: ScenarioPrioritiesRankByProjectScoreErrorType!
  path: [String!]!
}
type ScenarioSubmitToPlanOfRecordPayload {
  userError: ScenarioSubmitToPlanOfRecordUserError
  planOfRecord: PlanOfRecord
}
type ScenarioSubmitToPlanOfRecordUserError {
  message: String!
  type: ScenarioSubmitToPlanOfRecordErrorType!
  path: [String!]!
}
type ScenarioUpdatePayload {
  userError: ScenarioUpdateUserError
  scenario: Scenario
}
type ScenarioUpdateUserError {
  message: String!
  type: ScenarioUpdateErrorType!
  path: [String!]!
}
type ServiceDiscovery {
  chargeBear: ChargeBear!
  authenticorn: Authenticorn!
  linkLynx: LinkLynx!
  supportSeal: SupportSeal!
  pastePanda: PastePanda!
  pivotParrot: PivotParrot!
  maskedIcebear: MaskedIcebear!
  onboardingOtter: OnboardingOtter!
  apolloAlpaca: ApolloAlpaca!
  roadmapRaven: RoadmapRaven!
  listyLlama: ListyLlama!
  historyHamster: HistoryHamster!
  pushPiranha: PushPiranha!
  pipelinePunkupine: PipelinePunkupine!
  resourceRoadrunner: ResourceRoadrunner!
  exportEel: ExportEel!
  teamPlannerTurnip: TeamPlannerTurnip!
  commentCanary: CommentCanary!
  integrationIbex: IntegrationIbex!
  mailMeerkat: MailMeerkat!
  configCentipede: ConfigCentipede!
  filterFalcon: FilterFalcon!
  templanianTiger: TemplanianTiger!
  sandboxSandDollar: SandboxSandDollar!
}
type Skill {
  id: ID!
  name: String!
}
type SkillCreatePayload {
  userError: SkillCreateUserError
  skill: Skill
}
type SkillCreateUserError {
  message: String!
  type: SkillCreateErrorType!
  path: [String!]!
}
type SkillDeletePayload {
  userError: SkillDeleteUserError
}
type SkillDeleteUserError {
  message: String!
  type: SkillDeleteErrorType!
  path: [String!]!
}
type SkillUpdateNamePayload {
  userError: SkillUpdateNameUserError
  skill: Skill
}
type SkillUpdateNameUserError {
  message: String!
  type: SkillUpdateNameErrorType!
  path: [String!]!
}
type StringField {
  stringFieldDefinition: StringFieldDefinition!
  stringValue: String
}
type StringFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  unique: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not an empty string and not null"
  nonEmpty: Boolean!
}
type SupportSeal {
  baseUrlExternal: String!
}
type TeamPlannerTurnip {
  baseUrlExternal: String!
}
type TemplanianTiger {
  baseUrlExternal: String!
}
type TextField {
  textFieldDefinition: TextFieldDefinition!
  textValue: String
}
type TextFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type TigerBlogPost {
  blogPostId: ID!
  text: String!
}
type TigerBlogPostConnection {
  edges: [TigerBlogPostEdge!]!
  pageInfo: TigerBlogPostConnectionPageInfo!
  totalCount: Int!
}
type TigerBlogPostConnectionPageInfo {
  hasNextPage: Boolean!
}
type TigerBlogPostEdge {
  cursor: String!
  node: TigerBlogPost!
}
type TigerBlogPostPublishError {
  message: String!
  type: TigerBlogPostPublishErrorType!
  path: [String!]!
}
type TigerBlogPostPublishPayload {
  tigerBlogPost: TigerBlogPost
  userError: TigerBlogPostPublishError
}
type UpdateAllocationModePayload {
  mySettings: MySettings!
}
type UpdateWorkloadUnitPayload {
  mySettings: MySettings!
}
type UrlField {
  urlFieldDefinition: UrlFieldDefinition!
  urlValue: String
}
type UrlFieldDefinition implements FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
type User {
  id: ID!
  userName: String!
  email: String!
  activationState: UserActivationState!
  firstName: String
  lastName: String
  displayName: String!
  initials: String!
  lastLoginDate: ISO8601DateTime
  creationDate: ISO8601DateTime!
  passwordNeverExpires: Boolean!
  linkedResource: Resource
  userGroups(
    "Only values between 1 and 200 are valid."
    first: Int!,
    "Provide a cursor to paginate. Only either 'after' or 'offset' can be used but NOT both."
    after: String,
    "Provide an offset to paginate. Only either 'after' or 'offset' can be used but NOT both."
    offset: Int,filter: UserGroupFilterInput  ): UserGroupConnection!
  avatar: UserAvatar
  locale: String
  emailVerified: Boolean
}
type UserAvatar {
  url: String!
}
type UserAvatarDeleteError {
  message: String!
  type: UserAvatarDeleteErrorType!
  path: [String!]!
}
type UserAvatarDeletePayload {
  user: User
  userErrors: [UserAvatarDeleteError!]!
}
type UserAvatarUpdateError {
  message: String!
  type: UserAvatarUpdateErrorType!
  path: [String!]!
}
type UserAvatarUpdatePayload {
  user: User
  userErrors: [UserAvatarUpdateError!]!
}
type UserChangeActivationStateError {
  message: String!
  type: UserChangeActivationStateErrorType!
  path: [String!]!
}
type UserChangeActivationStatePayload {
  user: User
  userErrors: [UserChangeActivationStateError!]!
}
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: UserConnectionPageInfo!
  totalCount: Int!
}
type UserConnectionPageInfo {
  hasNextPage: Boolean!
}
type UserCreateError {
  message: String!
  type: UserCreateErrorType!
  path: [String!]!
}
type UserCreatePayload {
  user: User
  userErrors: [UserCreateError!]!
}
type UserEdge {
  cursor: String!
  node: User!
}
type UserGroup {
  id: ID!
  name: String!
  permissions: UserGroupPermissions!
  projectFields: UserGroupProjectFields!
  users(
    "Only values between 1 and 200 are valid."
    first: Int!,
    "Provide a cursor to paginate. Only either 'after' or 'offset' can be used but NOT both."
    after: String,
    "Provide an offset to paginate. Only either 'after' or 'offset' can be used but NOT both."
    offset: Int,filter: UserFilterInput  ): UserConnection!
}
type UserGroupConnection {
  edges: [UserGroupEdge!]!
  pageInfo: UserGroupConnectionPageInfo!
  totalCount: Int!
}
type UserGroupConnectionPageInfo {
  hasNextPage: Boolean!
}
type UserGroupCreateError {
  message: String!
  type: UserGroupCreateErrorType!
  path: [String!]!
}
type UserGroupCreatePayload {
  userGroup: UserGroup
  userErrors: [UserGroupCreateError!]!
}
type UserGroupDeleteError {
  message: String!
  type: UserGroupDeleteErrorType!
  path: [String!]!
}
type UserGroupDeletePayload {
  userErrors: [UserGroupDeleteError!]!
}
type UserGroupEdge {
  cursor: String!
  node: UserGroup!
}
type UserGroupPermissions {
  modifyProjectsAndPrograms: UserGroupPermissionScope!
  editPlanOfRecord: Boolean!
  replacePlanOfRecordWithScenario: Boolean!
  addProjectsAndPrograms: Boolean!
  deleteProjectsAndPrograms: Boolean!
  changeProjectRank: Boolean!
  sortProjectsByProjectScore: Boolean!
  changeProjectSchedule: Boolean!
  autoScheduleMultipleProjects: Boolean!
  addChangeAndDeleteFinancialEvents: Boolean!
  addChangeAndDeleteAllocations: Boolean!
  addChangeAndDeleteMilestones: Boolean!
  manageReports: UserGroupPermissionScope!
  managePortfolios: UserGroupPermissionScope!
  manageScenarios: UserGroupPermissionScope!
  manageResourcePoolAndAbsences: Boolean!
  manageProjectFields: Boolean!
  manageUsersAndUserGroups: Boolean!
  manageSubscriptions: Boolean!
  useMeisterplanApiAndExternalApplications: Boolean!
  importData: Boolean!
  exportData: Boolean!
  configureAndUseDataSources: Boolean!
  accessChangeLog: Boolean!
  configureQuickFilters: Boolean!
  accessActualTimeWorked: ActualTimeWorkedScope!
  accessFinancialData: Boolean!
  manageJiraLinks: Boolean!
  manageCustomViews: CustomViewsScope!
  manageSandbox: Boolean!
}
type UserGroupProjectFields {
  """
  this is a workaround because the gateway cannot reference the interface ProjectFieldDefinition by ID, it requires the concrete type which we don't have
  https://github.com/apollographql/apollo-server/issues/4361
  """
  readOnlyIds: [ID!]!
  """
  this is a workaround because the gateway cannot reference the interface ProjectFieldDefinition by ID, it requires the concrete type which we don't have
  https://github.com/apollographql/apollo-server/issues/4361
  """
  writeAndReadIds: [ID!]!
}
type UserGroupUpdateError {
  message: String!
  type: UserGroupUpdateErrorType!
  path: [String!]!
}
type UserGroupUpdatePayload {
  userGroup: UserGroup
  userErrors: [UserGroupUpdateError!]!
}
type UserReinviteError {
  message: String!
  type: UserReinviteErrorType!
  path: [String!]!
}
type UserReinvitePayload {
  user: User
  userErrors: [UserReinviteError!]!
}
type UserResendVerificationMailError {
  message: String!
  type: UserResendVerificationMailErrorType!
  path: [String!]!
}
type UserResendVerificationMailPayload {
  user: ID
  userErrors: [UserResendVerificationMailError!]!
}
type UserUpdateError {
  message: String!
  type: UserUpdateErrorType!
  path: [String!]!
}
type UserUpdateMyFirstNameError {
  message: String!
  type: UserUpdateMyFirstNameErrorType!
  path: [String!]!
}
type UserUpdateMyFirstNamePayload {
  user: User
  userErrors: [UserUpdateMyFirstNameError!]!
}
type UserUpdateMyLastNameError {
  message: String!
  type: UserUpdateMyLastNameErrorType!
  path: [String!]!
}
type UserUpdateMyLastNamePayload {
  user: User
  userErrors: [UserUpdateMyLastNameError!]!
}
type UserUpdateMyLocaleError {
  message: String!
  type: UserUpdateMyLocaleErrorType!
  path: [String!]!
}
type UserUpdateMyLocalePayload {
  user: User
  userErrors: [UserUpdateMyLocaleError!]!
}
type UserUpdatePayload {
  user: User
  userErrors: [UserUpdateError!]!
}
type ViewConfig {
  id: ID!
  name: String!
  jsonValue: String
  permissions: ViewConfigPermissions!
  displayStyle: ViewConfigDisplayStyle!
}
type ViewConfigActivateError {
  message: String!
  type: ViewConfigActivateErrorType!
  path: [String!]!
}
type ViewConfigActivatePayload {
  viewConfigList: ViewConfigList
  userError: ViewConfigActivateError
}
type ViewConfigCreateError {
  message: String!
  type: ViewConfigCreateErrorType!
  path: [String!]!
}
type ViewConfigCreatePayload {
  viewConfigList: ViewConfigList
  userError: ViewConfigCreateError
}
type ViewConfigDeleteError {
  message: String!
  type: ViewConfigDeleteErrorType!
  path: [String!]!
}
type ViewConfigDeletePayload {
  viewConfigList: ViewConfigList
  userError: ViewConfigDeleteError
}
type ViewConfigList {
  viewKey: ID!
  active: ViewConfig!
  configs: [ViewConfig!]!
}
type ViewConfigMetaDataUpdateError {
  message: String!
  type: ViewConfigMetaDataUpdateErrorType!
  path: [String!]!
}
type ViewConfigMetaDataUpdatePayload {
  viewConfigList: ViewConfigList
  userError: ViewConfigMetaDataUpdateError
}
type ViewConfigPermissions {
  users: [User!]!
  userGroups: [UserGroup!]!
}
type ViewConfigValueUpdateError {
  message: String!
  type: ViewConfigValueUpdateErrorType!
  path: [String!]!
}
type ViewConfigValueUpdatePayload {
  viewConfigList: ViewConfigList
  userError: ViewConfigValueUpdateError
}
type Webhook {
  "Id of the webhook."
  id: ID!
  "Customer defined name for this webhook."
  name: String!
  """
  Callback URL which will be called from a Meisterplan server when any event from `events` list is triggered.
  A blacklist defines forbidden URLs. The protocol has to be https.
  """
  callbackUrl: String!
  "List of event types which trigger this webhook."
  eventTypes: [WebhookEventType!]!
  "Scenario for which notifications are to be sent."
  scenario: Scenario
  "Project for which notifications are to be sent."
  project: Project
  """
  Customer defined secret for this webhook.
  If defined, the payload of the webhook is hashed with this secret
  and sent together with the payload in the header.
  """
  secret: String
  "Current status of this webhook."
  status: WebhookStatus!
  """
  User who has created this webhook.
  Updates by any user don't change this value.
  """
  createdBy: User
  "Server date time when the user created this webhook."
  createdDate: ISO8601DateTime!
}
type WebhookConnection {
  edges: [WebhookEdge!]!
  pageInfo: PageInfo!
}
type WebhookCreatePayload {
  userError: WebhookCreateUserError
  webhook: Webhook
}
type WebhookCreateUserError {
  message: String!
  type: WebhookCreateUserErrorType!
  path: [String!]!
}
type WebhookDeletePayload {
  userError: WebhookDeleteUserError
}
type WebhookDeleteUserError {
  message: String!
  type: WebhookDeleteUserErrorType!
  path: [String!]!
}
type WebhookEdge {
  cursor: String!
  node: Webhook!
}
type WebhookUpdateStatusPayload {
  userError: WebhookUpdateStatusUserError
  webhook: Webhook
}
type WebhookUpdateStatusUserError {
  message: String!
  type: WebhookUpdateStatusUserErrorType!
  path: [String!]!
}
interface Allocation {
  projectSchedule: ProjectSchedule!
  segments: [AllocationSegment!]!
  kpis: AllocationKPIs!
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costType: CostType
  "Missing ACCESS_FINANCIAL_DATA permission returns USER_RIGHT_MISSING error"
  costPerHour: Float
}
"""
Should actually be named PortfolioChangeLogRecord

We don't rename now since it would change a lot now and has almost no benefit. If the endpoint is changed, change this as well.
"""
interface ChangeLogRecord {
  id: ID!
  changedBy: ChangeLogChangedBy
  timestamp: ISO8601DateTime!
}
interface FieldDefinition {
  id: ID!
  externalId: String!
  name: String!
  isSystemField: Boolean!
  computed: Boolean!
  "If true, you must provide a value for this field when creating a new entity"
  mandatoryOnCreate: Boolean!
  permissions: FieldPermissions!
  isAssignable: Boolean!
  "If true, the field has no empty state. When explicitly updating this field you must provide a value that is not empty or null"
  nonEmpty: Boolean!
}
interface ProjectFinance {
  id: ID!
  value: Float!
  type: FinanceType!
  description: String
  financeCategory: FinanceCategory
  date: ISO8601Date!
}
interface Scenario {
  id: ID!
  legacyId: Int!
  name: String!
  projectSchedule(projectId: ID!): ProjectSchedule
  "first outside [0,500] returns INVALID_INPUT error"
  priorities(first: Int!, after: String): PrioritiesConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  projectSchedules(first: Int!, after: String, filter: ProjectFilterInput, sorting: ProjectScheduleSortingInput): ProjectScheduleConnection!
  "first outside [0,500] returns INVALID_INPUT error"
  programSchedules(first: Int!, after: String): ProgramScheduleConnection!
  roleCapacities(filter: RoleCapacitiesFilterInput): [RoleCapacity!]!
  "first outside [0,500] returns INVALID_INPUT error"
  milestoneScheduleDependencies(first: Int!, after: String): MilestoneScheduleDependencyConnection!
  milestoneSchedules(filter: MilestoneSchedulesFilterInput): [MilestoneSchedule!]!
  "first outside [0,3000] returns INVALID_INPUT error"
  allocations(first: Int!, after: String, filter: ScenarioAllocationFilterInput!): AllocationConnection!
  readOnly: Boolean!
}
union ActualsReferenceEntity = Role | Resource
union Allocatee = Resource | Role
union BusinessGoalOptional = BusinessGoal | BusinessGoalEmpty
union ChangeLogChangedBy = User | ChangeLogSystem
union ChangeLogProjectActuals = ChangeLogProjectActualsCreated | ChangeLogProjectActualsChanged | ChangeLogProjectActualsDeleted
union ChangeLogProjectAllocation = ChangeLogProjectAllocationChanged | ChangeLogProjectAllocationCreated | ChangeLogProjectAllocationDeleted
union ChangeLogProjectFinance = ProjectStartFinance | ProjectFinishFinance | ProjectMilestoneFinance | ProjectDateFinance
union ChangeLogProjectScheduleChangeField = ProjectScheduleChangeDateField | ProjectScheduleChangeRankCategoryField | ProjectScheduleChangeProgramField
union DateRangeConfiguration = FixedDateRangeConfiguration | RollingDateRangeConfiguration
union FinanceCategoryOptional = FinanceCategory | FinanceCategoryEmpty
union JiraAssignee = Role | Resource
union JiraEstimate = JiraStoryPointsEstimate | JiraDurationEstimate
union LookupFieldValueOptional = LookupFieldValue | LookupFieldValueEmpty
union ObsUnitOptional = ObsUnit | ObsUnitEmpty
union Priority = ProjectSchedulePriority | ProgramSchedulePriority
union ProgramChangeLogChange = ChangeLogProgramNameChange | ChangeLogProgramCreated | ChangeLogProgramDuplicated | ChangeLogProgramNameUnified
union ProgramScheduleResult = ProgramSchedule | ProgramScheduleEmpty
union ProjectChangeLogChange = ChangeLogStringFieldChange | ChangeLogBooleanFieldChange | ChangeLogDateFieldChange | ChangeLogDecimalFieldChange | ChangeLogIntegerFieldChange | ChangeLogLookupFieldChange | ChangeLogTextFieldChange | ChangeLogUrlFieldChange | ChangeLogBusinessGoalReferenceFieldChange | ChangeLogCostTypeFieldChange | ChangeLogResourceReferenceFieldChange | ChangeLogObsReferenceFieldChange | ChangeLogProjectScheduleChange | ChangeLogMilestoneNameChange | ChangeLogMilestonePhaseChange | ChangeLogMilestoneScheduleDateChange | ChangeLogMilestoneScheduleCreated | ChangeLogMilestoneScheduleDeleted | ChangeLogMilestoneScheduleAfterProjectScheduleFixed | ChangeLogProjectFinanceTypeChange | ChangeLogProjectFinanceAmountChange | ChangeLogProjectFinanceDescriptionChange | ChangeLogProjectFinanceCategoryChange | ChangeLogProjectFinanceTimingChange | ChangeLogProjectFinanceDateChange | ChangeLogProjectFinanceMilestoneScheduleChange | ChangeLogProjectFinanceCreated | ChangeLogProjectFinanceDeleted | ChangeLogProjectScheduleCreated | ChangeLogProjectScheduleDuplicated | ChangeLogProjectAllocationGroup | ChangeLogProjectActualsGroup | ChangeLogProjectScheduleCreatedFromScenario | ChangeLogProjectScheduleAppliedFromScenario | ChangeLogMilestoneScheduleDependencyCreated | ChangeLogMilestoneScheduleDependencyDeleted | ChangeLogProjectActualFinancialEventCreated | ChangeLogProjectActualFinancialEventAmountChanged | ChangeLogProjectActualFinancialEventBookingDateChanged | ChangeLogProjectActualFinancialEventCategoryChanged | ChangeLogProjectActualFinancialEventDescriptionChanged | ChangeLogProjectActualFinancialEventTypeChanged | ChangeLogProjectActualFinancialEventDeleted
union ProjectField = BooleanField | DateField | DecimalField | IntegerField | LookupField | StringField | TextField | UrlField | BusinessGoalReferenceField | CostTypeField | ResourceReferenceField | ObsReferenceField
union ProjectPhaseOptional = ProjectPhase | ProjectPhaseEmpty
union ProjectScheduleField = DateField | DateTimeField | DecimalField | ProgramScheduleReferenceField | RankCategoryField
union ResourceChangeLogChange = ChangeLogProjectAllocationChanged | ChangeLogProjectAllocationCreated | ChangeLogProjectAllocationDeleted
union ResourceOptional = Resource | ResourceEmpty
enum AbsenceDayType {
  FULL_DAY
  HALF_DAY
}
enum ActualFinancialEventDeleteUserErrorsType {
  SCENARIO_ID_INVALID
  PROJECT_ID_INVALID
  NO_SUFFICIENT_RIGHTS
  ACTUAL_FINANCIAL_EVENT_ID_INVALID
  ACTUAL_FINANCIAL_EVENT_ID_EMPTY
}
enum ActualFinancialEventEditUserErrorsType {
  SCENARIO_ID_INVALID
  PROJECT_ID_INVALID
  NO_SUFFICIENT_RIGHTS
  DESCRIPTION_TOO_LONG
  CATEGORY_ID_INVALID
  AMOUNT_NEGATIVE
  AMOUNT_NULL
  TYPE_NULL
  BOOKING_DATE_NULL
  ACTUAL_FINANCIAL_EVENT_ID_INVALID
}
enum ActualFinancialEventErrorType {
  NO_SUFFICIENT_RIGHTS
  AMOUNT_NEGATIVE
  "If provided scenario does not exist"
  SCENARIO_ID_INVALID
  "If provided project does not exist"
  PROJECT_ID_INVALID
  DESCRIPTION_TOO_LONG
  CATEGORY_ID_INVALID
}
enum ActualFinancialEventsUpdateMode {
  "Indicates that updating actual time worked fully replaces the existing value with the given value."
  REPLACE
  "Indicates that updating actual time worked adds the given value to the existing value."
  ADD
}
enum ActualsCreateOrUpdateErrorType {
  NO_SUFFICIENT_RIGHTS
  AMOUNT_NEGATIVE
  "Max amount is 100000000"
  AMOUNT_TOO_HIGH
  "If provided entity (role or resource) does not exist"
  ENTITY_ID_INVALID
  "If provided scenario does not exist"
  SCENARIO_ID_INVALID
  "If provided project does not exist"
  PROJECT_ID_INVALID
  COST_PER_HOUR_NEGATIVE
  "Max cost per hour is 1000000000"
  COST_PER_HOUR_TOO_HIGH
}
enum ActualSliceAggregationMode {
  WEEK
  MONTH
}
enum ActualsReferenceEntityType {
  ROLE
  RESOURCE
}
enum ActualTimeWorkedDeleteAllErrorType {
  NO_SUFFICIENT_RIGHTS
  "If provided scenario does not exist"
  SCENARIO_ID_INVALID
  "If provided project does not exist"
  PROJECT_ID_INVALID
}
enum ActualTimeWorkedDeleteErrorType {
  NO_SUFFICIENT_RIGHTS
  "If provided entity (role or resource) does not exist"
  ENTITY_ID_INVALID
  "If provided scenario does not exist"
  SCENARIO_ID_INVALID
  "If provided project does not exist"
  PROJECT_ID_INVALID
}
enum ActualTimeWorkedScope {
  NONE
  READ_ONLY
  WRITE_AND_READ
}
enum ActualTimeWorkedUpdateMode {
  "Indicates that updating actual time worked fully replaces the existing value with the given value."
  REPLACE
  "Indicates that updating actual time worked adds the given value to the existing value."
  ADD
}
enum Aggregation {
  WEEK
  MONTH
  "Aggregation in quarters based on the fiscal year configured in Meisterplan."
  FINANCIAL_QUARTER
  "Aggregation in years based on the fiscal year configured in Meisterplan."
  FINANCIAL_YEAR
}
enum AllocationMode {
  FLEXIBLE
  TIME_GRID
}
enum AllocationUnit {
  HOURS
  FTE
  DAYS
}
enum AmountUnit {
  HOURS
}
enum BusinessGoalCreateErrorType {
  BLANK
  TOO_LONG
}
enum CalendarCreateErrorType {
  BLANK
  DUPLICATE
  NEGATIVE_NUMBER
  NOT_FOUND
  OUT_OF_RANGE
  TOO_LONG
  WORK_TIME_EXCEPTION_DESCRIPTION_TOO_LONG
}
enum CalendarDeleteErrorType {
  NOT_FOUND
  DEFAULT_CALENDAR_NOT_DELETABLE
}
enum CalendarUpdateErrorType {
  BLANK
  DUPLICATE
  INVALID_PERIOD
  NEGATIVE_NUMBER
  NOT_FOUND
  OUT_OF_RANGE
  TOO_LONG
  WORK_TIME_EXCEPTION_DESCRIPTION_TOO_LONG
}
enum ChangeMyActiveCompareToScenarioErrorType {
  NOT_FOUND
}
enum ChangeMyActivePortfolioErrorType {
  NOT_FOUND
}
enum ChangeMyActiveScenarioErrorType {
  NOT_FOUND
}
enum CostType {
  "capital expense"
  CAPEX
  "operating expense"
  OPEX
}
enum CustomViewsScope {
  OWN
  SHARED_WITH
  ALL_SHARED
}
enum DateRangeConfigurationErrorType {
  INCONSISTENT
  INVALID_PERIOD
}
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}
enum DecimalFieldUnit {
  HOURS
  "see Instance.currency"
  SYSTEM_CURRENCY
  PERCENT
}
enum DefaultCalendarSetErrorType {
  NOT_FOUND
}
enum EpicsOrderBy {
  KEY
  STATUS
  EPIC_NAME
}
enum FieldPermissions {
  READ_AND_WRITE
  READ_ONLY
  NONE
}
enum FinanceTiming {
  PROJECT_START
  PROJECT_FINISH
  MILESTONE
  DATE
}
enum FinanceType {
  BENEFIT
  "capital expense"
  CAPEX
  "operating expense"
  OPEX
}
enum FinancialEventType {
  CAPEX
  OPEX
  BENEFIT
}
enum InactivityTimeoutUpdateErrorType {
  TIMEOUT_NOT_IN_RANGE
  MISSING_PERMISSION
}
enum InstanceUpdatePersonDayInHoursErrorType {
  OUT_OF_RANGE
}
enum InviteSource {
  ONBOARDING_CENTER_INVITE_USER
  CREATE_USER
}
enum JiraEffortType {
  STORY_POINTS
  DURATION_IN_HOURS
}
enum JiraFieldType {
  NUMBER
  DURATION
}
enum JiraIssueStatus {
  COMPLETED
  OPEN
}
enum JiraLinkCreateErrorType {
  NAME_TOO_LONG
  NAME_NOT_UNIQUE
  NAME_BLANK
  REMOTE_NOT_FOUND
  REMOTE_INVALID_CERTIFICATE
  REMOTE_PRIVATE_IP
  REMOTE_TIMEOUT
  MISSING_USER_PERMISSION
}
enum JiraLinkDeleteErrorType {
  JIRA_LINK_ID_NOT_FOUND
  MISSING_USER_PERMISSION
}
enum JiraLinkMappingMode {
  PROJECT
  ROLES
  RESOURCES
  ROLES_AND_RESOURCES
}
enum JiraLinkType {
  SERVER
  CLOUD
}
enum JiraLinkUpdateErrorType {
  JIRA_LINK_ID_NOT_FOUND
  NAME_TOO_LONG
  NAME_NOT_UNIQUE
  NAME_BLANK
  MISSING_USER_PERMISSION
  EFFORT_BASED_ON_BLANK
  RESOURCE_EFFORT_BASED_ON_BLANK
  MATCH_ROLES_TO_JIRA_FIELD_ID_BLANK
  VELOCITY_INVALID_NUMBER
  ROLE_ID_INVALID
}
enum JiraProjectLinkCreateOrUpdateErrorType {
  "Linkage can be up to 6000 characters long (maximum JQL query length)"
  LINK_TOO_LONG
  PROJECT_SCHEDULE_NOT_FOUND
  JIRA_LINK_NOT_FOUND
  MISSING_USER_PERMISSION
}
enum JiraProjectLinkDeleteErrorType {
  PROJECT_SCHEDULE_NOT_FOUND
  JIRA_PROJECT_LINK_NOT_FOUND
  MISSING_USER_PERMISSION
}
enum JiraProjectLinkType {
  "Jira issue is identified by an epic key"
  EPIC
  "Jira issue is identified by a jql query"
  JQL_QUERY
}
enum LicenseType {
  INTERNAL
  CUSTOMER
  CHARGEBEE_CUSTOMER
  CHARGEBEE_TRIAL
  SANDBOX
}
enum LoginNoticeUpdateErrorType {
  TOO_LONG
  FEATURE_SET_NOT_SUPPORTED
  MISSING_PERMISSION
}
enum LookupFieldValueCreateErrorType {
  BLANK
  NOT_FOUND
  TOO_LONG
}
enum MilestoneScheduleCreateErrorType {
  BLANK
  DUPLICATE
  INVALID_FORMAT
  NOT_FOUND
  OUT_OF_RANGE
  TOO_LONG
}
enum MilestoneScheduleDeleteErrorType {
  NOT_FOUND
}
enum MilestoneScheduleDependencyCreateErrorType {
  DUPLICATE
  INCONSISTENT
  NOT_FOUND
}
enum MilestoneScheduleDependencyDeleteErrorType {
  NOT_FOUND
}
enum MilestoneScheduleUpdateDateErrorType {
  NOT_FOUND
  OUT_OF_RANGE
}
enum MilestoneUpdateNameErrorType {
  BLANK
  NOT_FOUND
  TOO_LONG
}
enum MilestoneUpdateProjectPhaseErrorType {
  NOT_FOUND
}
enum ObsTypeCreateErrorType {
  BLANK
  TOO_LONG
  DUPLICATE
}
enum ObsTypeDeleteErrorType {
  NOT_FOUND
}
enum ObsTypeUpdateNameErrorType {
  NOT_FOUND
  BLANK
  TOO_LONG
  DUPLICATE
}
enum ObsUnitCreateErrorType {
  OBS_TYPE_NOT_FOUND
  PARENT_OBS_UNIT_NOT_FOUND
  PARENT_OBS_UNIT_DOES_NOT_MATCH_OBS_TYPE
  OBS_NAME_DUPLICATED
  NAME_TOO_LONG
  NAME_BLANK
}
enum ObsUnitDeleteErrorType {
  NOT_FOUND
}
enum ObsUnitFindOrCreateErrorType {
  BLANK
  TOO_LONG
  EMPTY
}
enum ObsUnitUpdateNameErrorType {
  NOT_FOUND
  BLANK
  TOO_LONG
  DUPLICATE
}
enum ObsUnitUpdateParentErrorType {
  NOT_FOUND
  OBS_UNIT_NAME_NOT_UNIQUE
  INVALID_TREE_STRUCTURE
  OBS_UNIT_MOVED_TO_WRONG_OBS_TYPE
}
enum OnboardingFlagUpdateError {
  KEY_TOO_LONG
  TOO_MANY_FLAGS
}
enum OnboardingRole {
  TRIAL_CREATOR
  SUB_PORTFOLIO_COORDINATOR
  PROJECT_MANAGER
}
enum OrderDirection {
  ASC
  DESC
}
enum PortfolioDesignerZoomLevel {
  YEAR
  QUARTER
  MONTH
  WEEK
}
enum PrioritiesRankIntoRankCategoryErrorType {
  NOT_FOUND
}
enum ProgramScheduleCreateErrorType {
  NOT_FOUND
  BLANK
  TOO_LONG
}
enum ProgramScheduleDeleteErrorType {
  NOT_FOUND
}
enum ProgramScheduleDuplicateErrorType {
  NOT_FOUND
}
enum ProgramScheduleRankByScoreErrorType {
  NOT_FOUND
}
enum ProgramScheduleRankRelativeToProgramScheduleErrorType {
  NOT_FOUND
}
enum ProgramScheduleRankRelativeToProgramSchedulePosition {
  ABOVE
  BELOW
}
enum ProgramScheduleRankRelativeToProjectScheduleErrorType {
  NOT_FOUND
  NOT_ON_TOP_LEVEL
}
enum ProgramScheduleRankRelativeToProjectSchedulePosition {
  ABOVE
  BELOW
}
enum ProgramUpdateNameErrorType {
  NOT_FOUND
  BLANK
  TOO_LONG
}
enum ProjectCommentCreateErrorType {
  MISSING_USER_PERMISSION
  TEXT_TOO_LONG
}
enum ProjectCommentDeleteUserErrorType {
  NOT_FOUND
  COMMENTS_OF_OTHER_USERS_CAN_NOT_BE_DELETED
  INVALID_UUID
}
enum ProjectCreateGenericErrorType {
  NOT_FOUND
  DUPLICATE
  BLANK
  NEGATIVE_NUMBER
  INVALID_PERIOD
  TOO_LONG
  EMPTY
  OUT_OF_RANGE
  INCONSISTENT
}
enum ProjectCreateUserErrorType {
  BUSINESSGOAL_NOT_FOUND
  DECIMAL_FIELD_VALUE_LESS_THAN_ZERO
  EXTERNALID_BLANK
  EXTERNALID_NOT_UNIQUE
  EXTERNALID_NOT_MODIFIABLE
  EXTERNALID_TOO_LONG
  PROJECT_KEY_NOT_MODIFIABLE
  FIELD_DUPLICATED
  FIELD_NOT_FOUND
  FINISH_BEFORE_OR_EQUAL_TO_START
  INTEGER_FIELD_VALUE_OUT_OF_RANGE
  LOOKUP_FIELD_VALUE_NOT_FOUND
  MANDATORY_FIELD_MISSING
  OBSUNIT_NOT_FOUND
  PORTFOLIO_NOT_FOUND
  RESOURCE_NOT_FOUND
  SCENARIO_NOT_FOUND
  STRING_FIELD_VALUE_NOT_UNIQUE
  STRING_FIELD_VALUE_TOO_LONG
  TEXT_FIELD_VALUE_TOO_LONG
  URL_FIELD_VALUE_TOO_LONG
  CONFLICTING_IDENTIFIERS
}
enum ProjectDateFinanceCreateErrorType {
  NOT_FOUND
  NEGATIVE_NUMBER
}
enum ProjectFinanceDeleteErrorType {
  NOT_FOUND
}
enum ProjectFinanceMoveToDateErrorType {
  NOT_FOUND
}
enum ProjectFinanceMoveToMilestoneErrorType {
  NOT_FOUND
  INCONSISTENT
}
enum ProjectFinanceMoveToProjectFinishErrorType {
  NOT_FOUND
}
enum ProjectFinanceMoveToProjectStartErrorType {
  NOT_FOUND
}
enum ProjectFinanceUpdateDescriptionErrorType {
  NOT_FOUND
}
enum ProjectFinanceUpdateFinanceCategoryErrorType {
  NOT_FOUND
}
enum ProjectFinanceUpdateTypeErrorType {
  NOT_FOUND
}
enum ProjectFinanceUpdateValueErrorType {
  NOT_FOUND
  NEGATIVE_NUMBER
}
enum ProjectFinishFinanceCreateErrorType {
  NOT_FOUND
  NEGATIVE_NUMBER
}
enum ProjectManagerEmailNotificationSchedule {
  "Daily notifications"
  DAILY
  "Weekly notifications"
  WEEKLY
}
enum ProjectMilestoneFinanceCreateErrorType {
  NOT_FOUND
  NEGATIVE_NUMBER
  INCONSISTENT
}
enum ProjectOverviewConfigurationFieldType {
  PROJECT_FIELD
  PROJECT_SCHEDULE_FIELD
}
enum ProjectOverviewConfigurationSaveErrorType {
  MISSING_REQUIRED_FIELDS @deprecated(reason: "not used anymore")
  AT_LEAST_ONE_FIELD_REQUIRED
  DUPLICATE_FIELD_ID
}
enum ProjectScheduleDeleteErrorType {
  NOT_FOUND
}
enum ProjectScheduleDuplicateErrorType {
  NOT_FOUND
}
enum ProjectScheduleExtendAllocationsErrorType {
  NOT_FOUND
  INVALID_PERIOD
  NO_ALLOCATIONS
}
enum ProjectScheduleExtensionMode {
  SHRINK_STRETCH
  STOP_OR_EXTEND_WITH_ZERO
  STOP_OR_EXTEND_ALLOCATION
}
enum ProjectScheduleInsertBreakErrorType {
  NOT_FOUND
  INVALID_PERIOD
  NO_ALLOCATIONS
}
enum ProjectScheduleMovePeriodErrorType {
  NOT_FOUND
}
enum ProjectScheduleRankByScoreErrorType {
  NOT_FOUND
}
enum ProjectScheduleRankRelativeToProgramScheduleErrorType {
  NOT_FOUND
}
enum ProjectScheduleRankRelativeToProgramSchedulePosition {
  ABOVE
  BELOW
  INTO
}
enum ProjectScheduleRankRelativeToProjectScheduleErrorType {
  NOT_FOUND
}
enum ProjectScheduleRankRelativeToProjectSchedulePosition {
  ABOVE
  BELOW
}
enum ProjectScheduleRemoveSectionErrorType {
  PROJECT_SCHEDULE_NOT_FOUND
  SECTION_END_BEFORE_START
  SECTION_NOT_IN_PERIOD
}
enum ProjectScheduleReplaceAllocationsErrorType {
  PROJECT_SCHEDULE_NOT_FOUND
  ROLE_NOT_FOUND
  RESOURCE_NOT_FOUND
  PROJECT_ROLE_NOT_FOUND
  PROJECT_ROLE_REQUIRED
  ALLOCATION_SEGMENT_END_BEFORE_START
  ALLOCATION_SEGMENTS_OVERLAP
  ALLOCATION_SEGMENT_VALUE_NEGATIVE
  ALLOCATION_SEGMENT_NON_ZERO_VALUE_OUTSIDE_PROJECT_PERIOD
  ALLOCATIONS_AMBIGUOUS
}
enum ProjectScheduleSplitAllocationsAtDateErrorType {
  PROJECT_SCHEDULE_NOT_FOUND
  OUT_OF_PERIOD
}
enum ProjectScheduleSubmitToScenarioErrorType {
  PROJECT_SCHEDULE_NOT_FOUND
  TARGET_SCENARIO_NOT_FOUND
}
enum ProjectScheduleUpdateDurationErrorType {
  NOT_FOUND
  INVALID_PERIOD
}
enum ProjectScheduleUpdateDurationMode {
  SHRINK_STRETCH
  STOP_OR_EXTEND_WITH_ZERO
  STOP_OR_EXTEND_ALLOCATION
}
enum ProjectStartFinanceCreateErrorType {
  NOT_FOUND
  NEGATIVE_NUMBER
}
enum ProjectUpdateFieldsErrorType {
  NOT_FOUND
  DUPLICATE
  BLANK
  NEGATIVE_NUMBER
  INVALID_PERIOD
  TOO_LONG
  EMPTY
  OUT_OF_RANGE
  INCONSISTENT
  VALUE_NOT_UNIQUE
}
enum ProjectViewConfigurationFieldType {
  PROJECT_FIELD
  PROJECT_SCHEDULE_FIELD
}
enum ProjectViewConfigurationSaveErrorType {
  INVALID_SECTION_ID
  INVALID_FIELD_ID
  EMPTY_SECTIONS
  DUPLICATE_MILESTONE_SECTION
  DUPLICATE_FINANCE_DATA_SECTION
  DUPLICATE_PROJECT_SCORE_SECTION
  DUPLICATE_TEAM_SECTION
  DUPLICATE_ACTUALS_SECTION
  DUPLICATE_FINANCIAL_TRACKER_SECTION
  DUPLICATE_TEAM_COST_SECTION
  DUPLICATE_COST_TYPE_SECTION
  NO_NAME_FOR_FIELD_SECTION
  FIELD_SECTION_NAME_TOO_LONG
  NO_FIELDS_ALLOWED_FOR_SECTION
  MISSING_REQUIRED_FIELDS @deprecated(reason: "not used anymore")
  AT_LEAST_ONE_FIELD_REQUIRED
  NOT_LICENSED_SECTION_USED
}
enum ProjectViewConfigurationSectionType {
  FIELD
  FINANCE_DATA
  MILESTONE
  PROJECT_SCORE
  TEAM
  ACTUALS
  FINANCIAL_TRACKER
  TEAM_COST
  COST_TYPE
}
enum RankCategory {
  ABOVE_MUST_HAVE
  "Below Must have and above cut off"
  REGULAR
  BELOW_CUT_OFF
}
enum RankingPosition {
  FIRST
  LAST
}
enum ResourceAbsencesCreateErrorType {
  OVERLAPS_EXISTING_ABSENCES
  INVALID_PERIOD
  OUTSIDE_PLANNABLE_DATE_RANGE
  RESOURCE_NOT_FOUND
}
enum ResourceAbsencesDeleteErrorType {
  NOT_FOUND
}
enum ResourceAbsencesUpdateErrorType {
  OVERLAPPING
  INVALID_PERIOD
  OUTSIDE_PLANNABLE_DATE_RANGE
  NOT_FOUND
}
enum ResourceAllocationCreateErrorType {
  NOT_FOUND
  ALLOCATION_ALREADY_EXISTS
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  VALUE_NEGATIVE
  SEGMENTS_OVERLAP
  PROJECT_ROLE_REQUIRED
}
enum ResourceAllocationCreateOrUpdateErrorType {
  NOT_FOUND
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  VALUE_NEGATIVE
  SEGMENTS_OVERLAP
  PROJECT_ROLE_REQUIRED
}
enum ResourceAllocationDeleteErrorType {
  NOT_FOUND
}
enum ResourceAllocationTransferToResourceErrorType {
  NOT_FOUND
  INVALID_PERIOD
}
enum ResourceAllocationUnstaffToProjectRoleErrorType {
  NOT_FOUND
  INVALID_PERIOD
}
enum ResourceAllocationUpdateErrorType {
  NOT_FOUND
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  VALUE_NEGATIVE
  SEGMENTS_OVERLAP
  PROJECT_ROLE_REQUIRED
}
enum ResourceAvatarDeleteErrorType {
  UNKNOWN
  NOT_FOUND
  RESOURCE_IS_LINKED_TO_USER
  MISSING_RESOURCE_POOL_PERMISSION
}
enum ResourceAvatarUpdateErrorType {
  UNKNOWN
  NOT_BASE64_ENCODED
  FILE_SIZE_TOO_LARGE
  INVALID_FORMAT
  EMPTY_ID
  RESOURCE_IS_LINKED_TO_USER
  MISSING_RESOURCE_POOL_PERMISSION
}
enum ResourceCreateErrorType {
  BLANK
  DUPLICATE
  INCONSISTENT
  INVALID_PERIOD
  NEGATIVE_NUMBER
  NOT_FOUND
  TOO_LONG
  RESOURCE_KEY_TOO_LONG
  RESOURCE_KEY_NOT_UNIQUE
}
enum ResourceDeleteErrorType {
  NOT_FOUND
}
enum ResourceManagerEmailNotificationSchedule {
  "Daily notifications"
  DAILY
  "Weekly notifications"
  WEEKLY
}
enum ResourceSortField {
  DISPLAY_NAME
  PRIMARY_ROLE_NAME
  OBS
}
enum ResourceStatus {
  INACTIVE
  ACTIVE
  FUTURE
}
enum ResourceUpdateCalendarDeviationsErrorType {
  EMPTY
  INCONSISTENT
  NOT_FOUND
}
enum ResourceUpdateErrorType {
  NOT_FOUND
  DUPLICATE
  BLANK
  NEGATIVE_NUMBER
  INVALID_PERIOD
  INCONSISTENT
  TOO_LONG
  RESOURCE_KEY_TOO_LONG
  RESOURCE_KEY_NOT_UNIQUE
}
enum ResourceUpdateLinkedUserErrorType {
  UNKNOWN
  ACCESS_NOT_PERMITTED
  USER_NOT_FOUND
}
enum RoleAllocationCreateErrorType {
  ALLOCATION_ALREADY_EXISTS
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  NOT_FOUND
  SEGMENTS_OVERLAP
  VALUE_NEGATIVE
}
enum RoleAllocationCreateOrUpdateErrorType {
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  NOT_FOUND
  SEGMENTS_OVERLAP
  VALUE_NEGATIVE
}
enum RoleAllocationDeleteErrorType {
  NOT_FOUND
}
enum RoleAllocationUpdateErrorType {
  END_BEFORE_START
  NON_ZERO_OUTSIDE_OF_PROJECT_SCHEDULE_SEGMENT
  NOT_FOUND
  SEGMENTS_OVERLAP
  VALUE_NEGATIVE
}
enum RoleCapacityUnit {
  FTE
  HOURS
  DAYS
}
enum RoleCapacityUpdateDeviationsErrorType {
  INVALID
  NOT_FOUND
}
enum RoleCreateErrorType {
  BLANK
  DUPLICATE
  NEGATIVE_NUMBER
  NOT_FOUND
  TOO_LONG
}
enum RoleDeleteErrorType {
  NOT_FOUND
}
enum RoleSortField {
  ROLE_NAME
  OBS
}
enum RoleUpdateErrorType {
  BLANK
  DUPLICATE
  INCONSISTENT
  NEGATIVE_NUMBER
  NOT_FOUND
  TOO_LONG
}
enum SandboxDeleteErrorType {
  MISSING_USER_PERMISSION
  SANDBOX_DOES_NOT_EXIST
  SANDBOX_OPERATION_IN_PROGRESS
}
enum SandboxLifecycleState {
  ACTIVE
  CREATING
  UPDATING
  DELETING
  ERROR
}
enum SandboxUpdateErrorType {
  MISSING_USER_PERMISSION
  SANDBOX_OPERATION_IN_PROGRESS
}
enum ScenarioCopyErrorType {
  BLANK
  TOO_LONG
  NOT_FOUND
}
enum ScenarioDeleteErrorType {
  SCENARIO_NOT_FOUND
}
enum ScenarioPrioritiesRankByProjectScoreErrorType {
  SCENARIO_NOT_FOUND
  PORTFOLIO_NOT_FOUND
  DOWNSTREAM_REFERENCE_NOT_FOUND
}
enum ScenarioSubmitToPlanOfRecordErrorType {
  SOURCE_SCENARIO_NOT_FOUND
}
enum ScenarioUpdateErrorType {
  SCENARIO_NOT_FOUND
  NAME_BLANK
  NAME_TOO_LONG
  USER_NOT_FOUND
}
enum ScheduleChangeAction {
  MOVE
  STOP
  EXTEND_WITH_ZERO_ALLOCATION
  RANK_HIGHER
  RANK_LOWER
  SHRINK
  STRETCH
  EXTEND_WITH_ALLOCATION
  FIELDS_CHANGED
  EXTEND_WITH_INSERTED_BREAK
  EXTEND_WITH_INSERTED_ALLOCATION
  REMOVE_SECTION
}
enum SkillCreateErrorType {
  BLANK
  DUPLICATE
  TOO_LONG
}
enum SkillDeleteErrorType {
  NOT_FOUND
}
enum SkillUpdateNameErrorType {
  BLANK
  DUPLICATE
  NOT_FOUND
  TOO_LONG
}
enum SortDirection {
  ASC
  DESC
}
enum TigerBlogPostPublishErrorType {
  MISSING_USER_PERMISSION
  TEXT_TOO_LONG
  TEXT_CONTAINS_BAD_WORDS
  BLOG_POST_ID_EXISTS_ALREADY
}
enum UserActivationState {
  ACTIVE
  DEACTIVATED
}
enum UserAvatarDeleteErrorType {
  UNKNOWN
  NOT_FOUND
}
enum UserAvatarUpdateErrorType {
  UNKNOWN
  NOT_BASE64_ENCODED
  FILE_SIZE_TOO_LARGE
  INVALID_FORMAT
}
enum UserChangeActivationStateErrorType {
  UNKNOWN
  ACCESS_NOT_PERMITTED
  NOT_FOUND
  CANNOT_CHANGE_OWN_USER
}
enum UserCreateErrorType {
  UNKNOWN
  ACCESS_NOT_PERMITTED
  TOO_SMALL_OR_TOO_LARGE
  INVALID_FORMAT
  DUPLICATE
  RESOURCE_ALREADY_ASSIGNED
}
enum UserGroupCreateErrorType {
  NOT_FOUND
  DUPLICATE
  BLANK
  TOO_SMALL_OR_TOO_LARGE
  UNKNOWN
  ACCESS_NOT_PERMITTED
  INVALID_COMBINATION
}
enum UserGroupDeleteErrorType {
  NOT_FOUND
  ACCESS_NOT_PERMITTED
  UNKNOWN
  WOULD_LOCK_OUT_SELF
}
enum UserGroupPermissionScope {
  NONE
  OWN
  ALL
}
enum UserGroupUpdateErrorType {
  NOT_FOUND
  DUPLICATE
  BLANK
  TOO_SMALL_OR_TOO_LARGE
  UNKNOWN
  ACCESS_NOT_PERMITTED
  INVALID_COMBINATION
  WOULD_LOCK_OUT_SELF
}
enum UserReinviteErrorType {
  UNKNOWN
  ACCESS_NOT_PERMITTED
  NOT_FOUND
  USER_ALREADY_LOGGED_IN
}
enum UserResendVerificationMailErrorType {
  UNKNOWN
  ALREADY_VERIFIED
}
enum UserRight {
  CHANGE_RESOURCE_POOL_AND_ABSENCES
  CHANGE_PROJECT_RANK
  SORT_PROJECT_LIST_BY_PROJECT_SCORE
  CHANGE_ADD_DELETE_ALLOCATIONS
  CHANGE_PROJECT_SCHEDULE
  AUTO_SCHEDULE_PROJECTS
  CREATE_PROJECTS
  DELETE_PROJECTS
}
enum UserUpdateErrorType {
  UNKNOWN
  ACCESS_NOT_PERMITTED
  TOO_SMALL_OR_TOO_LARGE
  INVALID_FORMAT
  NOT_FOUND
  DUPLICATE
  RESOURCE_ALREADY_ASSIGNED
  WOULD_LOCK_OUT_SELF
}
enum UserUpdateMyFirstNameErrorType {
  UNKNOWN
  TOO_SMALL_OR_TOO_LARGE
}
enum UserUpdateMyLastNameErrorType {
  UNKNOWN
  TOO_SMALL_OR_TOO_LARGE
}
enum UserUpdateMyLocaleErrorType {
  UNKNOWN
  INVALID_FORMAT
  NOT_SUPPORTED
}
enum ViewConfigActivateErrorType {
  VIEW_KEY_TOO_LONG
  ID_DOES_NOT_EXIST
}
enum ViewConfigCreateErrorType {
  VIEW_KEY_TOO_LONG
  USER_LIMIT_REACHED
  GROUP_LIMIT_REACHED
  NAME_TOO_LONG
  NAME_IS_BLANK
  VALUE_NOT_JSON
  VALUE_TOO_LONG
  INACCESSIBLE_CONFIG
  CREATING_SHARED_VIEW_CONFIG_NOT_ALLOWED
}
enum ViewConfigDeleteErrorType {
  VIEW_KEY_TOO_LONG
  ID_DOES_NOT_EXIST
  NO_ACCESS_TO_VIEW_CONFIG
  DELETING_SHARED_VIEW_CONFIG_NOT_ALLOWED
}
enum ViewConfigDisplayStyle {
  PRIVATE
  SHARED
}
enum ViewConfigMetaDataUpdateErrorType {
  VIEW_KEY_TOO_LONG
  ID_DOES_NOT_EXIST
  USER_LIMIT_REACHED
  GROUP_LIMIT_REACHED
  NAME_TOO_LONG
  NAME_IS_BLANK
  INACCESSIBLE_CONFIG
  NO_ACCESS_TO_VIEW_CONFIG
  UPDATING_SHARED_VIEW_CONFIG_NOT_ALLOWED
  SHARING_VIEW_CONFIG_NOT_ALLOWED
}
enum ViewConfigValueUpdateErrorType {
  VIEW_KEY_TOO_LONG
  ID_DOES_NOT_EXIST
  VALUE_NOT_JSON
  VALUE_TOO_LONG
  NO_ACCESS_TO_VIEW_CONFIG
  UPDATING_SHARED_VIEW_CONFIG_NOT_ALLOWED
}
enum WebhookCreateUserErrorType {
  "Name of the webhook must bot be blank."
  NAME_BLANK
  "The maximum length for the name is 2048 characters."
  NAME_TOO_LONG
  """
  The callback URL underlays some restrictions.
  Maximum length is 2048 characters.
  There is also a blacklist of forbidden URLs.
  """
  CALLBACK_URL_INVALID
  SCENARIO_NOT_FOUND
  PROJECT_NOT_FOUND
  "Secrets can't be longer than 256 characters."
  SECRET_INVALID
  "User permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS is necessary for any CRUD operation."
  MISSING_USER_PERMISSION
  """
  The number of webhooks is limited per system.
  Currently the limit is set to 1000.
  """
  TOO_MANY_WEBHOOKS
  "List of event types must not be empty"
  EMPTY_EVENT_TYPES
}
enum WebhookDeleteUserErrorType {
  NOT_FOUND
  "User permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS is necessary for any CRUD operation."
  MISSING_USER_PERMISSION
}
enum WebhookEventType {
  PROJECT_CREATE
  PROJECT_UPDATE
  PROJECT_DELETE
}
enum WebhookStatus {
  SUSPENDED
  ACTIVE
}
enum WebhookUpdateStatus {
  SUSPENDED
  ACTIVE
}
enum WebhookUpdateStatusUserErrorType {
  NOT_FOUND
  "User permission USE_MEISTERPLAN_API_AND_EXTERNAL_APPLICATIONS is necessary for any CRUD operation."
  MISSING_USER_PERMISSION
}
enum WeekDisplayUnit {
  FIRST_DAY_OF_WEEK
  CALENDAR_WEEK
}
enum WorkloadUnit {
  FTE
  PD
  HOURS
}
input AbsenceCreateInput {
  start: ISO8601Date!
  end: ISO8601Date!
  startType: AbsenceDayType! = FULL_DAY
  endType: AbsenceDayType! = FULL_DAY
}
input AbsenceSliceFilterInput {
  period: SliceFilterPeriodInput!
}
input ActualFinancialEventEditInput {
  scenarioId: ID!
  projectId: ID!
  actualFinancialEventId: ID!
  bookingDate: ISO8601Date
  amount: Float
  type: FinancialEventType
  categoryId: ID
  description: String
}
input ActualFinancialEventEntitiesFilterInput {
  ids: [ID!]!
}
input ActualFinancialEventInput {
  bookingDate: ISO8601Date!
  amount: Float!
  type: FinancialEventType!
  categoryId: ID
  description: String
}
input ActualFinancialEventsCreateOrUpdateInput {
  scenarioId: ID!
  projectId: ID!
  actualFinancialEvents: [ActualFinancialEventInput!]!
  updateMode: ActualFinancialEventsUpdateMode!
}
input ActualFinancialEventsDeleteInput {
  projectId: ID!
  scenarioId: ID!
  actualFinancialEventIds: [ID!]!
}
input ActualsCreateOrUpdateInput {
  projectId: ID!
  scenarioId: ID!
  actualsReferenceEntityType: ActualsReferenceEntityType!
  actualsReferenceEntityId: ID!
  actuals: [ActualsInput!]!
  "Optional. Default mode if not set is REPLACE."
  updateMode: ActualTimeWorkedUpdateMode
}
input ActualsInput {
  bookingDate: ISO8601Date!
  """
  amount is in hours with a maximum precision of 4 decimal places
  and a maximum number of digits of 14 (including decimal places)
  """
  amount: Float!
  unit: AmountUnit!
  costType: CostType
  """
  The cost per hour (based on your system's currency) for this resource.
  A negative value will cause UserError with type NEGATIVE_NUMBER.
  Defining a value (including null) requires user permission ACCESS_FINANCIAL_DATA.
  """
  costPerHour: Float
}
"""
A period to be used when querying slices.
It is only considered valid if `start` is before `finish`.
The `start` and `finish` dates are inclusive.
"""
input ActualSlicePeriodInput {
  "from is inclusive"
  from: ISO8601Date!
  "to is inclusive"
  to: ISO8601Date!
}
input ActualTimeWorkedDeleteAllInput {
  projectId: ID!
  scenarioId: ID!
}
input ActualTimeWorkedDeleteInput {
  projectId: ID!
  scenarioId: ID!
  actualsReferenceEntityType: ActualsReferenceEntityType!
  actualsReferenceEntityId: ID!
}
input ActualTimeWorkedFilterInput {
  "Allows to return only the actuals whose booking date is at or after the provided input."
  from: ISO8601Date
  "Allows to return only the actuals whose booking date is before the provided input."
  to: ISO8601Date
  "Allows to return only the actuals for a specific role or resource."
  actualTimeWorkedReferenceEntity: ActualTimeWorkedReferenceEntityInput
}
input ActualTimeWorkedReferenceEntityInput {
  type: ActualsReferenceEntityType!
  id: ID!
}
input AllocationFilterInput {
  "Filters allocations to those associated with projects scheduled in the given scenario."
  scenarioId: ID!
  "Filters allocations to those at least partly scheduled within the given period."
  period: AllocationPeriodInput!
}
input AllocationPeriodInput {
  start: ISO8601Date!
  end: ISO8601Date!
}
input AllocationSegmentInput {
  start: ISO8601Date!
  end: ISO8601Date!
  unit: AllocationUnit!
  value: Float!
}
input AllocationSliceFilterInput {
  "The period to be used when querying allocation slices."
  period: SliceFilterPeriodInput!
}
input BooleanFieldInput {
  """
  The ID of the field to set a value for.
  An unknown boolean field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The boolean value to set.
  A `null` value causes a reset to the default value `false`.
  """
  booleanValue: Boolean
}
input BooleanFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown boolean field `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The boolean value to set.
  A `null` value will cause a reset to the default value `false`.
  """
  booleanValue: Boolean!
}
input BusinessGoalCreateInput {
  """
  The name of the business goal to add.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  "The RGB color code of the business goal to add."
  color: HexColorCode
}
input BusinessGoalReferenceFieldInput {
  """
  The ID of the field to set a value for.
  An unknown business goal reference field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The business goal value to set.
  An unknown business goal ID causes an error of type `NOT_FOUND`.
  """
  businessGoalReferenceValue: String
}
input BusinessGoalReferenceFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown business goal reference field `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  "The business goal value to set."
  businessGoalReferenceValue: String
}
input CalendarCreateInput {
  """
  The name of the calendar to add.
  A blank string causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  The `ID` of an existing calendar to be the parent of the new calendar. Can be omitted to create a top-level calendar.
  An unknown `ID` causes `UserError` with type `NOT_FOUND`.
  """
  parentCalendarId: ID
  """
  The regular work time for each day of the week.
  A work time value less than zero causes `UserError` with type `NEGATIVE_NUMBER`.
  A work time value greater than 24.0 causes `UserError` with type `OUT_OF_RANGE`.
  """
  regularWorkTime: CalendarRegularWorkTimeInput!
  """
  Dated exceptions from the regular work time.
  A work time value less than zero causes `UserError` with type `NEGATIVE_NUMBER`.
  A work time value greater than 24.0 causes `UserError` with type `OUT_OF_RANGE`.
  Multiple exceptions for the same date cause `UserError` with type `DUPLICATE`.
  A description longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  workTimeExceptions: [CalendarWorkTimeExceptionInput!]
}
input CalendarDeleteInput {
  """
  The `ID` of the calendar to delete.
  An unknown `ID` causes `UserError` with type `NOT_FOUND`.
  Trying to delete the system's default calendar or any of its ancestors causes `UserError` with type `UNSUPPORTED_STATE`.
  """
  id: ID!
}
"""
A calendar deviation specifiying a deviation from the resource's default capacity in a given period.
The `start` must be before `finish` and `relativeCapacity` is not allowed to be negative.
Valid date range for calendar deviations is the closed range [1970-1-1, 2079-7-3].
Failing to adhere to these rules will cause `UserError` with type `INCONSISTENT`.
"""
input CalendarDeviationInput {
  start: ISO8601Date
  end: ISO8601Date
  relativeCapacity: Float!
}
input CalendarRegularWorkTimeInput {
  onMondays: Float!
  onTuesdays: Float!
  onWednesdays: Float!
  onThursdays: Float!
  onFridays: Float!
  onSaturdays: Float!
  onSundays: Float!
}
input CalendarUpdateInput {
  """
  The `ID` of the calendar to update.
  An unknown `ID` causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
  """
  The updated name of the calendar. Can be omitted to keep the calendar's current name.
  A blank string causes `UserError` with type `BLANK`.
  A string longer than 2048 characts causes `UserError` with type `TOO_LONG`.
  """
  name: String
  """
  The updated regular work time for each day of the week. Can be omitted to keep the calendar's current regular work time.
  A work time value less than zero causes `UserError` with type `NEGATIVE_NUMBER`.
  A work time value greater than 24.0 causes `UserError` with type `OUT_OF_RANGE`.
  """
  regularWorkTime: CalendarRegularWorkTimeInput
  "Dated exceptions from the regular work time to replace the existing exceptions in a given period. Can be omitted to keep the calendar's current work time exceptions."
  workTimeExceptionsPatch: CalendarWorkTimeExceptionsPatch
}
input CalendarWorkTimeExceptionFilterInput {
  "Allows to return only the exceptions dated after the provided input."
  after: ISO8601Date
  "Allows to return only the exceptions dated before the provided input."
  before: ISO8601Date
}
input CalendarWorkTimeExceptionInput {
  date: ISO8601Date!
  workTimeInHours: Float!
  description: String!
}
input CalendarWorkTimeExceptionsPatch {
  """
  The start date of the period to replace exceptions in. All existing exceptions before this date will be kept.
  Omit to replace all exceptions before 'keepExceptionsAfter'. Omit both to replace all exceptions.
  A date equal to or after `keepExceptionsAfter` causes `UserError` with type `INVALID_PERIOD`.
  """
  keepExceptionsBefore: ISO8601Date
  """
  The end date of the period to replace exceptions in. All existing exceptions after this date will be kept.
  Omit to replace all exceptions after 'keepExceptionsBefore'. Omit both to replace all exceptions.
  A date equal to or before `keepExceptionsBefore` causes `UserError` with type `INVALID_PERIOD`.
  """
  keepExceptionsAfter: ISO8601Date
  """
  Dated exceptions from the regular work time. Can be left empty to remove all existing exceptions within the given period.
  A work time value less than zero causes `UserError` with type `NEGATIVE_NUMBER`.
  A work time value greater than 24.0 causes `UserError` with type `OUT_OF_RANGE`.
  Multiple exceptions for the same date cause `UserError` with type `DUPLICATE`.
  A date not within the given period causes `UserError` with type `OUT_OF_RANGE`.
  A description longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  exceptions: [CalendarWorkTimeExceptionInput!]!
}
input ChangeMyActiveCompareToScenarioInput {
  """
  The `ID` of the scenario to load by default.
  Unknown `ID` will cause GraphQLClientException.
  """
  scenarioId: ID
}
input ChangeMyActivePortfolioInput {
  """
  The `ID` of the portfolio to load by default.
  Unknown `ID` will cause GraphQLClientException.
  """
  portfolioId: ID!
}
input ChangeMyActiveScenarioInput {
  """
  The `ID` of the scenario to load by default.
  Unknown `ID` will cause GraphQLClientException.
  """
  scenarioId: ID!
}
input CostTypeFieldInput {
  """
  The ID of the field to set a value for.
  An unknown cost type field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The cost type value to set.
  A `null` value causes a reset to the default value `OPEX`.
  """
  costTypeValue: CostType
}
input CostTypeFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown cost type field `ID` will cause `
  ` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The cost type value to set.
  A `null` value will cause a reset to the default value `OPEX`.
  """
  costTypeValue: CostType
}
input CurrencyFieldInput {
  """
  The ID of the field to set a value for.
  An unknown currency field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  "The currency value to set."
  currencyValue: Float
}
input DateFieldInput {
  """
  The ID of the field to set a value for.
  An unknown date field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  "The date value to set."
  dateValue: ISO8601Date
}
input DateFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown date field `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  "The date value to set."
  dateValue: ISO8601Date
}
"""
The new DateRangeConfiguration to be set for the requesting user.
If both input fields are defined, fixedConfiguration takes precedence and rollingConfiguration is ignored.
Defining both inputs with null will cause `UserError` with type `INCONSISTENT`.
Specifying invalid dates or period will cause `UserError` with type `INVALID_PERIOD`.
"""
input DateRangeConfigurationInput {
  fixedConfiguration: FixedDateRangeConfigurationInput
  rollingConfiguration: RollingDateRangeConfigurationInput
}
input DecimalFieldInput {
  """
  The ID of the field to set a value for.
  An unknown decimal field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The decimal value to set.
  A value less than zero causes an error with type `OUT_OF_RANGE` if values less than zero are not supported by the field.
  """
  decimalValue: Float
}
input DecimalFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown decimal field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The decimal value to set.
  Value less than zero causes `UserError` with type `OUT_OF_RANGE` if values less than zero are not supported by the field.
  """
  decimalValue: Float
}
input DefaultCalendarSetInput {
  """
  The `ID` of an existing calendar to set as the system's default calendar.
  An unknown `ID` causes `UserError` with type `NOT_FOUND`.
  """
  calendarId: String!
}
input DestinationRankByScoreFilterInput {
  portfolioId: ID
  period: ProjectPeriodFilterInput
}
"""
A employment period to be used in mutation inputs for resources.
It is only considered valid if `start` is before `finish` and if both are within valid date range.
Valid date range for employment period is the closed range [1970-1-1, 2079-7-3].
A `start` equal to or after `finish` causes `UserError` with type `INVALID_PERIOD`.
Setting `start` or `finish` or both outside of the plannable date range causes `UserError` with type `INCONSISTENT`.
"""
input EmploymentPeriodInput {
  start: ISO8601Date
  termination: ISO8601Date
}
input FixedDateRangeConfigurationInput {
  startMonth: Int!
  startYear: Int!
  endMonth: Int!
  endYear: Int!
}
input InactivityTimeoutUpdateInput {
  minutes: Int!
}
input InstanceUpdatePersonDayInHoursInput {
  """
  The number of hours corresponding to a full working day.
  Values outside the closed range [0.1, 24.0] will cause `UserError` with type `OUT_OF_RANGE`
  """
  personDayInHours: Float!
}
input IntegerFieldInput {
  """
  The ID of the field to set a value for.
  An unknown integer field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The integer value to set.
  A value less than -9007199254740992 or larger than 9007199254740992 causes an error with type `OUT_OF_RANGE`.
  The value is represented as Float in the schema to support the whole range. Because GraphQL Int is limited to 32bit.
  Decimal places are ignored.
  """
  integerValue: Float
}
input IntegerFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown integer field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The integer value to set.
  Value less than -9007199254740992 or larger than 9007199254740992 causes `UserError` with type `OUT_OF_RANGE`.
  The value is represented as Float in the schema to support the whole range. Because GraphQL Int is limited to 32bit.
  Decimal places are ignored.
  """
  integerValue: Float
}
input JiraEpicsFilterInput {
  searchText: String
  status: String
  project: String
}
input JiraEpicsSortingInput {
  orderDirection: OrderDirection
  orderBy: EpicsOrderBy
}
input JiraLinkCreateInput {
  """
  Name of the Jira link
  A blank value will cause an user error of type 'NAME_BLANK'
  A too long name (> 2048) will cause an user error of type 'NAME_TOO_LONG'
  The name must be unique. An non-unique name will cause an user error of type 'NAME_NOT_UNIQUE'
  """
  name: String!
  """
  Url to the Jira system
  If the service cannot connect to the Jira System it will cause an user error of type 'REMOTE_NOT_FOUND'
  If the connection times out it will cause an user error of type 'REMOTE_TIMEOUT'
  If the url results in a private ip it will cause an user error of type  'REMOTE_PRIVATE_IP'
  """
  url: String!
  ignoreCertificate: Boolean!
}
input JiraLinkDeleteInput {
  """
  Id of the Jira link to delete
  A non-existing Jira link will cause an user error of type 'JIRA_LINK_ID_NOT_FOUND'
  """
  id: ID!
}
input JiraLinkRoleVelocityFactorInput {
  "A role id which is not an uuid will cause an user error of type 'ROLE_ID_INVALID'"
  roleId: ID!
  "A value <=0 will cause an user error of type 'VELOCITY_INVALID_NUMBER'"
  velocityFactor: Float!
}
input JiraLinkRoleVelocityFactorsUpdateInput {
  jiraLinkId: ID!
}
input JiraLinkUpdateInput {
  """
  Id of the Jira link to update
  A non-existing Jira will cause an user error of type 'JIRA_LINK_ID_NOT_FOUND'
  """
  id: ID!
  """
  Name of the Jira link
  A blank value will cause an user error of type 'NAME_BLANK'
  A too long name (> 2048) will cause an user error of type 'NAME_TOO_LONG'
  The name must be unique. An non-unique name will cause an user error of type 'NAME_NOT_UNIQUE'
  """
  name: String!
  mappingMode: JiraLinkMappingMode!
  """
  Id of the Jira effort field
  A blank value will cause an user error of type 'EFFORT_BASED_ON_BLANK'
  """
  effortBasedOnFieldId: ID
  """
  Id of the Jira resource effort field
  A blank value will cause an user error of type 'RESOURCE_EFFORT_BASED_ON_BLANK'
  """
  resourceEffortBasedOnFieldId: ID
  """
  Use the given Jira Field ID as a data source for matching Meisterplan roles.
  A blank value will cause an user error of type 'MATCH_ROLES_TO_JIRA_FIELD_ID_BLANK'
  """
  matchRolesToJiraFieldId: ID
  """
  Value to transfer story points to effort in hours
  A value <=0 will cause an user error of type 'VELOCITY_INVALID_NUMBER'
  """
  velocity: Float
  """
  Associate Meisterplan Roles with their velocity factor.
  Associations not passed will be deleted.
  """
  roleVelocityFactors: [JiraLinkRoleVelocityFactorInput!]
}
input JiraProjectLinkCreateOrUpdateInput {
  projectScheduleId: ID!
  jiraLinkId: ID!
  projectLinkType: JiraProjectLinkType!
  link: String!
}
input JiraProjectLinkDeleteInput {
  projectScheduleId: ID!
}
input LoginNoticeUpdateInput {
  loginNotice: String
}
input LookupFieldInput {
  """
  The ID of the field to set a value for.
  An unknown lookup field ID will causes with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the lookup field value to set.
  An unknown lookup field value ID causes an error with type `NOT_FOUND`.
  """
  lookupValue: ID
}
input LookupFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown lookup field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the lookup field value to set.
  Unknown lookup field value `ID` causes `UserError` with type `NOT_FOUND`.
  """
  lookupValue: ID
}
input LookupFieldValueCreateInput {
  """
  The id of any ProjectLookupFieldDefinition that can be retrieved e.g. via projectFieldDefinitions or projectStatusFieldDefinition.
  No field definition of type lookup with this `ID` causes `UserError` with type `NOT_FOUND`.
  """
  lookupFieldDefinitionId: ID!
  """
  The name of the status value to create.
  A blank string causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  The color to represent the status value.
  Omitting this field or setting it to null will create the status value without color representation.
  """
  color: HexColorCode
}
input MilestoneScheduleCreateInput {
  """
  The ID of the project schedule to add the milestone to.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  An client generated milestone schedule ID for an optimistic UI.
  An already existing ID causes `UserError` with type `DUPLICATE`.
  An ID which is not in UUID format cases `UserError` with type `INVALID_FORMAT`.
  """
  clientProvidedMilestoneScheduleId: ID
  """
  An client generated milestone ID for an optimistic UI.
  An already existing ID causes `UserError` with type `DUPLICATE`.
  An ID which is not in UUID format cases `UserError` with type `INVALID_FORMAT`.
  """
  clientProvidedMilestoneId: ID
  """
  The date to schedule the milestone at.
  A date before the project schedule's start date, after the its finish date or within gaps causes `UserError` with type `OUT_OF_RANGE`.
  """
  date: ISO8601Date!
  """
  The name of the milestone to add.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  The ID of the project phase that leads to the milestone.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  projectPhaseId: ID
}
input MilestoneScheduleDeleteInput {
  """
  The ID of the milestone schedule to delete.
  An unknown ID returns `UserError` with type `NOT_FOUND`.
  """
  milestoneScheduleId: ID!
}
input MilestoneScheduleDependencyCreateInput {
  """
  The ID of the milestone schedule where the dependency should start.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  fromMilestoneScheduleId: ID!
  """
  The ID of the milestone schedule where the dependence should end.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  toMilestoneScheduleId: ID!
}
input MilestoneScheduleDependencyDeleteInput {
  """
  The ID of the milestone schedule where the dependency starts.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  fromMilestoneScheduleId: ID!
  """
  The ID of the milestone schedule where the dependence ends.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  toMilestoneScheduleId: ID!
}
input MilestoneSchedulesFilterInput {
  milestoneId: ID
}
input MilestoneScheduleUpdateDateInput {
  """
  The ID of the milestone schedule to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  milestoneScheduleId: ID!
  """
  The date to schedule the milestone at.
  A date before the project schedule's start date, after the its finish date or within gaps causes `UserError` with type `OUT_OF_RANGE`.
  """
  date: ISO8601Date!
}
input MilestoneUpdateNameInput {
  """
  The ID of a scenario the milestone is scheduled in.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  The ID of the milestone to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  An ID of a milestone not scheduled in the scenario causes `UserError` of type `NOT_FOUND`.
  """
  milestoneId: ID!
  """
  The new name of the milestone.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
}
input MilestoneUpdateProjectPhaseInput {
  """
  The ID of a scenario the milestone is scheduled in.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  The ID of the milestone to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  An ID of a milestone not scheduled in the scenario causes `UserError` of type `NOT_FOUND`.
  """
  milestoneId: ID!
  """
  The ID of the project phase to set.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  projectPhaseId: ID
}
input MySettingsUpdateWeekDisplayUnitInput {
  weekDisplayUnit: WeekDisplayUnit!
}
input ObsFilterInput {
  "The `ID` of the OBS type to apply a filter to."
  obsTypeId: ID!
  """
  The `ID`s of the OBS units to filter by. Resources or Roles have to match any of the given values.
  Explicitly include `null` to match Resources or Roles without a value for this OBS reference field.
  """
  obsUnitIds: [ID]!
}
"""
Input to update OBS associations for existing `Resource` and `Role`.
Allows both to create new assocations and to change or delete existing ones.
"""
input ObsInput {
  """
  The OBS type of the OBS unit association to create or modify.
  Unknown OBS type `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  obsType: ID!
  """
  The OBS unit `ID` that should be associated with the `Resource` or `Role`.
  Set this explicitly to null to remove the OBS association.
  Note that a role can not be associated with more than one OBS unit of the same OBS type.
  Unknown OBS unit `ID` will cause `UserError` with type `NOT_FOUND`.
  Assigning a OBS unit of the same OBS type as a already associated OBS unit causes `UserError` with type `DUPLICATE`.
  Specifying a OBS unit that has a different OBS type than the one specified in `obsType` causes `UserError` with type `INCONSISTENT`.
  """
  obsUnit: ID
}
input ObsReferenceFieldInput {
  """
  The ID of the field to set a value for.
  An unknown OBS reference field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the OBS unit to set.
  An unknown OBS unit ID causes an error with type `NOT_FOUND`.
  """
  obsReferenceValue: ID
}
input ObsReferenceFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown obs reference field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the obs reference field value to set.
  Unknown obs reference field value `ID` causes `UserError` with type `NOT_FOUND`.
  """
  obsReferenceValue: ID
}
input ObsTypeCreateInput {
  """
  The name of the OBS type to create.
  An already existing name will cause `UserError` with type `DUPLICATE`.
  A blank name causes `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
}
input ObsTypeDeleteInput {
  """
  The `ID` of the OBS type to delete.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
}
input ObsTypeUpdateNameInput {
  """
  The `ID` of the OBS type to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
  """
  The new name of the OBS type.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  A name already given to another existing skill causes `UserError` with type `DUPLICATE`.
  """
  name: String!
}
input ObsUnitCreateInput {
  """
  Obs Type ID of the new Obs Unit.
  An unknown ID causes `UserError` with type `OBS_TYPE_NOT_FOUND`.
  """
  obsTypeId: ID!
  """
  Parent Obs Unit  ID of the new Obs Unit.
  An unknown ID causes `UserError` with type `PARENT_OBS_UNIT_NOT_FOUND`.
  """
  parentObsUnitId: ID
  """
  The name of the OBS unit to create.
  An already existing name will cause `UserError` with type `OBS_NAME_DUPLICATED`.
  A blank name causes `UserError` with type `NAME_BLANK`.
  String longer than 2048 characters causes `UserError` with type `NAME_TOO_LONG`.
  """
  name: String!
}
input ObsUnitDeleteInput {
  """
  The `ID` of the OBS unit to delete.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
}
input ObsUnitFindOrCreateInput {
  """
  The name of the desired OBS type. If it can't be found it will be created.
  A blank name causes `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  obsTypeName: String!
  """
  The desired OBS units for the type specified in `obsTypeName`.
  Any OBS unit that can't be found will be created.
  The ordering in the list specifies the OBS unit's hierarchy.
  An empty list causes `UserError` with type `EMPTY`.
  Blank unit names inside the list cause `UserError` with type `BLANK`.
  Strings longer than 2048 characters cause `UserError` with type `TOO_LONG`.
  """
  obsUnitNamePathFromRoot: [String!]!
}
input ObsUnitUpdateNameInput {
  """
  The `ID` of the OBS unit to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
  """
  The new name of the OBS unit
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  A name already given to another existing skill causes `UserError` with type `DUPLICATE`.
  """
  name: String!
}
input ObsUnitUpdateParentInput {
  """
  The `ID` of the OBS unit to be updated.
  All child units and project- and resource-relations will be preserved.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
  """
  The `ID` of the OBS unit to be set as parent.
  An ommitted or null value will update the unit to have its type as parent.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  Parent unit already containing a child unit with same name as unit to be updated causes `UserError` with type `OBS_UNIT_NAME_NOT_UNIQUE`.
  Detaching subtrees from the OBS Type causes `UserError` with type `INVALID_TREE_STRUCTURE`.
  Referencing a unit of another type causes `UserError` with type `OBS_UNIT_MOVED_TO_WRONG_OBS_TYPE`.
  """
  newParentUnitId: ID
}
input OnboardingFlagInput {
  id: ID!
  value: Boolean!
}
"""
A generic period to be used in mutation inputs.
It is only considered valid if `start` is before `finish`.
`start` equal to or after `finish` causes `UserError` with type `INVALID_PERIOD`.
"""
input PeriodInput {
  start: ISO8601Date!
  finish: ISO8601Date!
}
input PortfolioChangeLogAdditionalFilterInput {
  "Supports currently only FieldDefinitions in a project."
  fieldDefinitionIds: [ID!]! = []
  milestones: Boolean! = false
  financials: Boolean! = false
  allocations: Boolean! = false
  actuals: Boolean! = false
  rankChanges: Boolean! = false
  scheduleChanges: Boolean! = false
  actualFinancials: Boolean! = false
}
input PortfolioChangeLogFilterInput {
  scenarioId: ID!
  portfolioId: ID!
  "Only changes for projects within period will be returned."
  period: PortfolioChangeLogPeriodFilterInput!
  "The id of the top-level change can be used to page sub-elements effectively."
  id: ID
  "If defined it will filter for the defined records"
  additionalFilter: PortfolioChangeLogAdditionalFilterInput
}
input PortfolioChangeLogPeriodFilterInput {
  start: ISO8601Date!
  end: ISO8601Date!
}
"A postal address to be used in mutation inputs."
input PostalAddressInput {
  """
  The city name to set. Omit to leave unchanged or empty respectively.
  String longer than 255 characters causes `UserError` with type `TOO_LONG`.
  """
  city: String
  """
  The country name to set. Omit to leave unchanged or empty respectively.
  String longer than 255 characters causes `UserError` with type `TOO_LONG`.
  """
  country: String
  """
  The postal code to set. Omit to leave unchanged or empty respectively.
  String longer than 255 characters causes `UserError` with type `TOO_LONG`.
  """
  postalCode: String
}
input PrioritiesRankIntoRankCategoryInput {
  """
  The ID of the scenario to modify.
  An unknown ID causes user error with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  The IDs of the project schedules and program schedules to be updated in their desired order after re-ranking.
  An unknown ID causes user error with type `NOT_FOUND`.
  An ID associated with a project schedule or program schedule of another scenario causes user error with type `NOT_FOUND`.
  An ID associated with a project schedule that is part of a program detaches the project schedule from the program and re-ranks it on top level.
  """
  priorityIds: [ID!]!
  "The rank category to apply."
  rankCategory: RankCategory!
  "The position within the rank category block of the scenario to place the schedules at."
  position: RankingPosition!
}
input ProgramChangeLogFilterInput {
  scenarioId: ID!
  programId: ID!
}
input ProgramScheduleCreateInput {
  """
  The ID of the scenario to modify.
  Unknown ID returns `UserError` with type `NOT_FOUND`.
  """
  scenario: ID!
  """
  Name of the program to add.
  Blank String causes `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  The ID of an existing program schedule or project schedule (not project!) to be used as a reference to rank the added program schedule.
  
  If the reference corresponds to an existing program schedule or top-level project schedule, the added program schedule will be ranked below the reference.
  If the reference corresponds to an existing project schedule that is ranked in a program schedule, the added program schedule is ranked below that program schedule.
  If the reference does not exist or is omitted, the added program schedule is ranked last above cut-off.
  
  In any case, if the user lacks the `CHANGE_PROJECT_RANKS` permission, the added program schedule will be ranked first below cut-off.
  """
  priorityReference: ID
}
input ProgramScheduleDeleteInput {
  """
  The ID of the program schedule to delete.
  An unknown program schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  programScheduleId: ID!
}
input ProgramScheduleDuplicateInput {
  """
  The ID of the program schedule to duplicate.
  An unknown ID causes user error of type `NOT_FOUND`.
  """
  programScheduleId: ID!
}
input ProgramScheduleRankByScoreInput {
  """
  The `ID` of the program schedule to be ranked by score.
  An unknown `ID` causes an `UserError` with type `NOT_FOUND`.
  """
  programScheduleId: ID!
}
input ProgramScheduleRankRelativeToProgramScheduleInput {
  """
  The ID of the program schedule to rank.
  An unknown ID causes user error of type `NOT_FOUND`.
  """
  programScheduleId: ID!
  """
  The ID of a program schedule used as reference to rank the program schedule.
  An unknown ID or an ID associated with another scenario causes user error of type `NOT_FOUND`.
  """
  referenceProgramScheduleId: ID!
  "The position to rank the program schedule relative to the reference program schedule."
  position: ProgramScheduleRankRelativeToProgramSchedulePosition!
}
input ProgramScheduleRankRelativeToProjectScheduleInput {
  """
  The ID of the program schedule to rank.
  An unknown ID causes user error of type `NOT_FOUND`.
  """
  programScheduleId: ID!
  """
  The ID of a project schedule used as reference to rank the program schedule.
  An unknown ID or an ID associated with another scenario causes user error of type `NOT_FOUND`.
  An ID associated with a project schedule that is part of a program causes user error of type `NOT_ON_TOP_LEVEL`.
  """
  referenceProjectScheduleId: ID!
  "The position to rank the program schedule relative to the reference project schedule."
  position: ProgramScheduleRankRelativeToProjectSchedulePosition!
}
input ProgramUpdateNameInput {
  """
  The ID of the program to update.
  An unknown program `ID` causes `UserError` with type `NOT_FOUND`.
  """
  programId: ID!
  """
  The ID of the scenario containing the program to update.
  An unknown scenario `ID` causes `UserError` with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  Name of the program to set.
  Blank String causes `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
}
input ProjectBooleanFieldFilterInput {
  "The `ID` of the boolean field to apply a filter to."
  booleanFieldDefinitionId: ID!
  "The boolean value to filter by. Boolean fields are always set, so projects have to match the given value."
  booleanValue: Boolean!
}
input ProjectBusinessGoalReferenceFieldFilterInput {
  "The `ID` of the business goal reference field to apply a filter to."
  businessGoalReferenceFieldDefinitionId: ID!
  """
  The `ID`s of the business goals to filter by. Projects have to match any of the given values.
  Explicitly include `null` to match projects without a value for this business goal reference field.
  """
  businessGoalIds: [ID]!
}
"When defined only one condition needs to match"
input ProjectChangeLogAdditionalFilterInput {
  "Supports currently only FieldDefinitions in a project."
  fieldDefinitionIds: [ID!]! = []
  milestones: Boolean! = false
  financials: Boolean! = false
  allocations: Boolean! = false
  actuals: Boolean! = false
  rankChanges: Boolean! = false
  scheduleChanges: Boolean! = false
  actualFinancials: Boolean! = false
}
input ProjectChangeLogFilterInput {
  scenarioId: ID!
  projectId: ID!
  "The id of the top level change can be used to page sub elements effectively."
  id: ID
  "If defined it will filter for the defined records"
  additionalFilter: ProjectChangeLogAdditionalFilterInput
}
input ProjectCommentCreateInput {
  scenarioId: ID!
  projectId: ID!
  text: String!
  mentionedUserIds: [ID!]
}
input ProjectCommentDeleteInput {
  id: ID!
}
input ProjectCreateGenericFieldsInput {
  booleanFields: [BooleanFieldInput!]
  businessGoalReferenceFields: [BusinessGoalReferenceFieldInput!]
  costTypeFields: [CostTypeFieldInput!]
  dateFields: [DateFieldInput!]
  decimalFields: [DecimalFieldInput!]
  integerFields: [IntegerFieldInput!]
  lookupFields: [LookupFieldInput!]
  obsReferenceFields: [ObsReferenceFieldInput!]
  resourceReferenceFields: [ResourceReferenceFieldInput!]
  stringFields: [StringFieldInput!]
  textFields: [TextFieldInput!]
  urlFields: [UrlFieldInput!]
}
input ProjectCreateGenericInput {
  """
  The ID of the scenario to modify.
  An unknown scenario ID causes an error with type `NOT_FOUND`.
  """
  scenario: ID!
  """
  The ID of the portfolio to put the project into.
  An unknown portfolio ID causes an error with type `NOT_FOUND`.
  """
  portfolio: ID
  """
  An optional user defined `ID` for the project.
  Use this to reference the created project with the one in your source system.
  Omit or pass `null` to set a randomly generated externalId.
  Pass the externalId of a project already existing in another scenario to schedule that project in the given scenario and apply properties.
  A blank externalId causes an error with type `BLANK`.
  A string longer than 2048 characters causes an error with type `TOO_LONG`.
  An externalId already used by another project in the same scenario causes an error with type `DUPLICATE`.
  Passing the externalId of a project from another scenario alongside a project key may cause an error of type `INCONSISTENT`.
  """
  externalId: ID
  """
  The ID of an existing program schedule or project schedule (not project!) to be used as a reference to rank the added project schedule.
  
  If the reference corresponds to an existing program schedule or project schedule, the added project schedule will be ranked below the reference.
  If the reference does not exist or is omitted, the added project schedule is ranked last above cut-off.
  
  In any case, if the user lacks the `CHANGE_PROJECT_RANKS` permission, the added project schedule will be ranked first below cut-off.
  """
  priorityReference: ID
  """
  The values for various project fields.
  See `projectFieldDefinitions` query to get the field definitions with their possible value IDs or value ranges respectively.
  """
  fields: ProjectCreateGenericFieldsInput
}
input ProjectCreateInput {
  """
  The ID of the scenario to modify.
  An unknown scenario ID causes an error with type `SCENARIO_NOT_FOUND`.
  """
  scenario: ID!
  """
  The ID of the portfolio to put the project into.
  An unknown portfolio ID causes an error with type `PORTFOLIO_NOT_FOUND`.
  """
  portfolio: ID
  """
  An optional user defined `ID` for the project.
  Use this to reference the created project with the one in your source system.
  Omit or pass `null` to set a randomly generated externalId.
  Pass the externalId of a project already existing in another scenario to schedule that project in the given scenario and apply properties.
  A blank externalId causes an error with type `EXTERNALID_BLANK`.
  A string longer than 2048 characters causes an error with type `EXTERNALID_TOO_LONG`.
  An externalId already used by another project in the same scenario causes an error with type `EXTERNALID_NOT_UNIQUE`.
  Passing the externalId of a project from another scenario alongside a project key may cause errors of type `CONFLICTING_IDENTIFIERS` or `PROJECT_KEY_NOT_MODIFIABLE`.
  """
  externalId: ID
  """
  An optional user defined unique identifier of the project.
  Pass the project key of a project already existing in another scenario to schedule that project in the given scenario and apply properties.
  A string longer than 2048 characters causes an error with type `STRING_FIELD_VALUE_TOO_LONG`.
  A projectKey already used by another project in the same scenario causes an error with type `STRING_FIELD_VALUE_NOT_UNIQUE`.
  Passing the project key of a project from another scenario alongside an externalId may cause errors of type `CONFLICTING_IDENTIFIERS` or `EXTERNALID_NOT_MODIFIABLE`.
  """
  projectKey: ID
  """
  The name of the project to create.
  A blank string causes an error with type `MANDATORY_FIELD_MISSING`.
  A string longer than 2048 characters causes an error with type `STRING_FIELD_VALUE_TOO_LONG`.
  """
  name: String!
  """
  The project's scheduled period.
  The period's end date must be at least one day after its start.
  An invalid period causes an error with type `FINISH_BEFORE_OR_EQUAL_TO_START`.
  """
  period: PeriodInput!
  """
  The ID of an existing program schedule or project schedule (not project!) to be used as a reference to rank the created project schedule.
  
  If the reference corresponds to an existing program schedule or project schedule, the added project schedule will be ranked below the reference.
  If the reference does not exist or is omitted, the added project schedule is ranked last above the cut-off line.
  
  In any case, if the user lacks the `CHANGE_PROJECT_RANKS` permission, the added project schedule will be ranked first below the cut-off line.
  """
  priorityReference: ID
  """
  One of the possible `CostType` values for the project.
  If omitted or `null`, this will default to `OPEX`.
  """
  costType: CostType
  """
  Notes to the project.
  A string longer than 32000 characters causes an error with type `TEXT_FIELD_VALUE_TOO_LONG`.
  """
  notes: String
  """
  The ID of a resource to assign as the manager of the project.
  See `resources` query to get resource IDs.
  An unknown resource ID causes an error with type `RESOURCE_NOT_FOUND`.
  """
  manager: ID
  """
  The ID of the business goal of the project.
  See `businessGoals` query to get business goal `ID`s.
  An unknown business goal ID causes an error with type `BUSINESSGOAL_NOT_FOUND`.
  """
  businessGoal: ID
  """
  The ID of the value for the project status field.
  See `projectStatusFieldDefinition` query to get the field definition with all possible value IDs.
  An unknown status field value ID causes an error with type `LOOKUP_FIELD_VALUE_NOT_FOUND`.
  """
  status: ID
  """
  The approved total effort to set on the project.
  A value less than zero causes an error with type `DECIMAL_FIELD_VALUE_LESS_THAN_ZERO`.
  """
  approvedTotalEffort: Float
  """
  The values for various project fields.
  See `projectFieldDefinitions` query to get the field definitions with their possible value IDs or value ranges respectively.
  Inputs for non-existing or inaccessible fields cause an error with type `FIELD_NOT_FOUND`.
  Multiple inputs for the same field (including those passed explicitly) cause an error with type `FIELD_DUPLICATED`.
  """
  fields: ProjectFieldsInput
  """
  The IDs of the OBS units the project should be associated with.
  See `obsTypes` query to get OBS types with their OBS unit IDs.
  Note that a project can not be associated with more than one OBS unit of the same OBS type.
  An unknown OBS unit `ID` causes an error with type `OBSUNIT_NOT_FOUND`.
  Assigning more than one OBS unit of the same OBS type causes an error with type `FIELD_DUPLICATED`.
  """
  obsUnits: [ID!]
}
input ProjectCustomFieldFilterInput {
  "The `ID` of the custom field to be considered when filtering projects."
  definitionId: ID!
  """
  The value that needs to be matched exactly by the project's custom field value.
  Null matches unset field values.
  """
  value: String
}
input ProjectDateFinanceCreateInput {
  """
  The ID of the project schedule to add the ProjectFinance.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  date: ISO8601Date!
  type: FinanceType!
  """
  The currency value to set.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  """
  value: Float!
  description: String
  """
  The ID of the finance category for this ProjectFinance.
  An unknown finance category `ID` causes `UserError` with type `NOT_FOUND`.
  """
  financeCategoryId: ID
}
input ProjectFieldsInput {
  booleanFields: [BooleanFieldInput!]
  dateFields: [DateFieldInput!]
  decimalFields: [DecimalFieldInput!]
  integerFields: [IntegerFieldInput!]
  lookupFields: [LookupFieldInput!]
  stringFields: [StringFieldInput!]
  textFields: [TextFieldInput!]
  urlFields: [UrlFieldInput!]
}
input ProjectFilterInput {
  projectScheduleIds: [ID!]
  portfolioId: ID
  projectId: ID
  externalId: String
  name: String
  """
  Allows to return only the projects whose customfields match the provided input.
  Only ProjectStringFields, ProjectTextFields, ProjectUrlFields and ProjectIntegerFields are supported!
  """
  customFields: [ProjectCustomFieldFilterInput!]
  "Allows to return only the projects whose boolean fields match the provided input."
  booleanFields: [ProjectBooleanFieldFilterInput!]
  "Allows to return only the projects whose business goal reference fields match the provided input."
  businessGoalReferenceFields: [ProjectBusinessGoalReferenceFieldFilterInput!]
  "Allows to return only the projects whose lookup fields match the provided input."
  lookupFields: [ProjectLookupFieldFilterInput!]
  "Allows to return only the projects whose OBS reference fields match the provided input."
  obsReferenceFields: [ProjectObsReferenceFieldFilterInput!]
  "Allows to return only the projects whose resource reference fields match the provided input."
  resourceReferenceFields: [ProjectResourceReferenceFieldFilterInput!]
  """
  Allows to return only the projects from a specific rank category of the scenario.
  Passing an empty list leads to the same result as passing no list.
  """
  rankCategories: [RankCategory!]
  period: ProjectPeriodFilterInput
  """
  Allows to return only the projects whose program association matches the provided input.
  Omitting the parameter or passing null matches projects with any program association including those without programs
  """
  programId: ID
  """
  projectKey filter is exact case-insensitive match.
  Blank input is interpreted as no filter.
  """
  projectKey: String
  "Allows to return only the projects whose name or project key case insensitively contains the provided input."
  searchTerm: String
}
input ProjectFinanceDeleteInput {
  """
  The ID of the project finance to delete.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
}
input ProjectFinanceMoveToDateInput {
  """
  The ID of the project finance to update.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
  date: ISO8601Date!
}
input ProjectFinanceMoveToMilestoneInput {
  """
  The ID of the project finance to move.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  A known project finance `ID` not in the same project schedule as the milestone schedule causes `UserError` with type `INCONSISTENT`
  """
  projectFinanceId: ID!
  """
  The ID of the milestone schedule to move the project finance to.
  An unknown milestone schedule `ID` causes `UserError` with type `NOT_FOUND`.
  A known milestone schedule `ID` not in the same project schedule as the project finance causes `UserError` with type `INCONSISTENT`
  """
  milestoneScheduleId: ID!
}
input ProjectFinanceMoveToProjectFinishInput {
  """
  The ID of the project finance to move.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
}
input ProjectFinanceMoveToProjectStartInput {
  """
  The ID of the project finance to move.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
}
input ProjectFinanceUpdateDescriptionInput {
  """
  The ID of the project finance to update.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
  "The new description."
  description: String!
}
input ProjectFinanceUpdateFinanceCategoryInput {
  """
  The ID of the project finance to update.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
  """
  The ID of the finance category for this ProjectFinance.
  An unknown finance category `ID` causes `UserError` with type `NOT_FOUND`.
  """
  financeCategoryId: ID
}
input ProjectFinanceUpdateTypeInput {
  """
  The ID of the project finance to update.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
  "The new finance type."
  type: FinanceType!
}
input ProjectFinanceUpdateValueInput {
  """
  The ID of the project finance to update.
  An unknown project finance `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectFinanceId: ID!
  "The new value."
  value: Float!
}
input ProjectFinishFinanceCreateInput {
  """
  The ID of the project schedule to add the ProjectFinance.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  type: FinanceType!
  """
  The currency value to set.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  """
  value: Float!
  description: String
  """
  The ID of the finance category for this ProjectFinance.
  An unknown finance category `ID` causes `UserError` with type `NOT_FOUND`.
  """
  financeCategoryId: ID
}
input ProjectLookupFieldFilterInput {
  "The `ID` of the lookup field to apply a filter to."
  lookupFieldDefinitionId: ID!
  """
  The `ID`s of the lookup values to filter by. Projects have to match any of the given values.
  Explicitly include `null` to match projects without a value for this lookup field.
  """
  lookupFieldValueIds: [ID]!
}
input ProjectMilestoneFinanceCreateInput {
  """
  The ID of the project schedule to add the ProjectFinance.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The ID of the milestone to associate the ProjectFinance with.
  An unknown milestone schedule `ID` causes `UserError` with type `NOT_FOUND`.
  A milestone schedule `ID` not being part of the referenced project schedule causes `UserError` with type `INCONSISTENT`.
  """
  milestoneScheduleId: ID!
  type: FinanceType!
  """
  The currency value to set.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  """
  value: Float!
  description: String
  """
  The ID of the finance category for this ProjectFinance.
  An unknown finance category `ID` causes `UserError` with type `NOT_FOUND`.
  """
  financeCategoryId: ID
}
input ProjectObsReferenceFieldFilterInput {
  "The `ID` of the OBS reference field to apply a filter to."
  obsReferenceFieldDefinitionId: ID!
  """
  The `ID`s of the OBS units to filter by. Projects have to match any of the given values.
  Explicitly include `null` to match projects without a value for this OBS reference field.
  """
  obsUnitIds: [ID]!
}
input ProjectOverviewConfigurationInput {
  selectedFields: [ProjectOverviewSelectedFieldInput!]!
}
input ProjectOverviewSelectedFieldInput {
  id: String!
  type: ProjectOverviewConfigurationFieldType!
}
input ProjectPeriodFilterInput {
  "Allows to return only the projects whose end date or latest finance date is scheduled at or after the provided input."
  after: ISO8601Date
  "Allows to return only the projects whose start date or earliest finance date is scheduled at or before the provided input."
  before: ISO8601Date
}
input ProjectResourceReferenceFieldFilterInput {
  "The `ID` of the resource reference field to apply a filter to."
  resourceReferenceFieldDefinitionId: ID!
  """
  The `ID`s of the resources to filter by. Projects have to match any of the given values.
  Explicitly include `null` to match projects without a value for this resource reference field.
  """
  resourceIds: [ID]!
}
input ProjectScheduleDeleteInput {
  """
  The ID of the project schedule to delete.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
}
input ProjectScheduleDuplicateInput {
  projectScheduleId: ID!
}
input ProjectScheduleExtendAllocationsInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  start: ISO8601Date!
  finish: ISO8601Date!
  """
  Whether to leave the absolute allocation values of segments moved by the
  extension untouched (false) or to update them to keep the FTE value unchanged.
  Defaults to false.
  """
  keepFTE: Boolean
}
"The `start` must be before `finish`."
input ProjectScheduleInsertBreakInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  start: ISO8601Date!
  finish: ISO8601Date!
  """
  Whether to leave the absolute allocation values of segments moved by the break
  untouched (false) or to update them to keep the FTE value unchanged.
  Defaults to false.
  """
  keepFTE: Boolean
}
input ProjectScheduleMovePeriodInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  "The new start date of the project schedule."
  start: ISO8601Date!
  """
  Whether to leave the absolute allocation values untouched (false)
  or to update them to keep the FTE value unchanged.
  Defaults to false.
  """
  keepFTE: Boolean
}
input ProjectScheduleRankByScoreInput {
  """
  The `ID` of the project schedule to be ranked by score.
  An unknown `ID` or an `ID` pointing to a project schedule that is part of a program schedule causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
}
input ProjectScheduleRankRelativeToProgramScheduleInput {
  """
  The ID of the project schedule to rank.
  An unknown ID causes user error of type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The ID of a program schedule used as reference to rank the project schedule.
  An unknown ID or an ID associated with another scenario causes user error of type `NOT_FOUND`.
  """
  referenceProgramScheduleId: ID!
  "The position to rank the project schedule relative to the reference program schedule."
  position: ProjectScheduleRankRelativeToProgramSchedulePosition!
}
input ProjectScheduleRankRelativeToProjectScheduleInput {
  """
  The ID of the project schedule to rank.
  An unknown ID causes user error of type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The ID of a project schedule used as reference to rank the project schedule.
  An unknown ID or an ID associated with another scenario causes user error of type `NOT_FOUND`.
  """
  referenceProjectScheduleId: ID!
  "The position to rank the project schedule relative to the reference project schedule."
  position: ProjectScheduleRankRelativeToProjectSchedulePosition!
}
input ProjectScheduleRemoveSectionInput {
  """
  The project schedule ID of the project schedule to change.
  An unknown project ID causes a user error with type `PROJECT_SCHEDULE_NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The period of the section to be removed.
  A period that is not completely inside the project period causes a user error with type `SECTION_NOT_IN_PERIOD`.
  A period that covers the whole project period causes a user error with type `SECTION_NOT_IN_PERIOD`.
  """
  sectionToRemove: PeriodInput!
  "This flag can be used to specify whether the FTE values are to be kept constant in the FTE mode when moving the project part behind the removed section."
  keepFTE: Boolean!
}
input ProjectScheduleReplaceAllocationsInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule ID causes a user error with type `PROJECT_SCHEDULE_NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The role allocations to apply to the project schedule.
  All existing role allocations will be overwritten. Leave empty to delete all existing role allocations.
  Multiple allocations with the same role ID cause user error with type `ALLOCATIONS_AMBIGUOUS`.
  """
  roleAllocations: [RoleAllocationInput!]!
  """
  The resource allocations to apply to the project schedule.
  All existing resource allocations will be overwritten. Leave empty to delete all existing resource allocations.
  Multiple allocations with the same combination of resource ID and project role ID cause user error with type `ALLOCATIONS_AMBIGUOUS`.
  """
  resourceAllocations: [ResourceAllocationInput!]!
}
"""
Sorting criteria for project schedules in a scenario.
Omit to sort project schedules by natural order which means ascending by their rank.
"""
input ProjectScheduleSortingInput {
  """
  The field definition `ID` of any project or project schedule field to sort by.
  Omit to sort project schedules by natural order using their rank.
  An invalid or unknown `ID` as well as the `ID` of an inaccessible or unsupported field will be ignored
  and sort project schedules by natural order using their rank.
  """
  fieldDefinitionId: ID
  direction: SortDirection!
}
input ProjectScheduleSplitAllocationsAtDateInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule ID causes a user error with type `PROJECT_SCHEDULE_NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The date to split the allocations at.
  A date outside of the project period causes an user error of type `OUT_OF_PERIOD`.
  """
  date: ISO8601Date!
}
input ProjectScheduleSubmitToScenarioInput {
  """
  The project ID of the project schedule to copy from one scenario to another.
  An unknown project ID causes a user error with type `PROJECT_SCHEDULE_NOT_FOUND`.
  """
  projectId: ID!
  """
  The ID of the scenario to submit the project schedule from.
  An unknown scenario ID or an ID of a scenario without a project schedule for the given project causes a user error with type `PROJECT_SCHEDULE_NOT_FOUND`.
  """
  sourceScenarioId: ID!
  """
  The ID of the scenario to apply the project schedule to.
  Any existing schedule for the given project will be overwritten in the target scenario.
  An unknown scenario ID causes a user error with type `TARGET_SCENARIO_NOT_FOUND`.
  """
  targetScenarioId: ID!
}
input ProjectScheduleUpdateDurationInput {
  """
  The ID of the project schedule to modify.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  """
  The new duration of the project schedule.
  A duration less than 1 causes `UserError` with type `INVALID_PERIOD`
  """
  duration: Int!
  """
  The modes for extending or shrinking a project schedule.
  If you provide a duration shorter than the current one in combination with the mode Zero Allocation or Extend Allocation,
  the project will be stopped at the date corresponding to the requested duration.
  Defaults to EXTEND_WITH_ZERO.
  """
  mode: ProjectScheduleUpdateDurationMode
}
input ProjectsFilterInput {
  ids: [ID!]
}
input ProjectStartFinanceCreateInput {
  """
  The ID of the project schedule to add the ProjectFinance.
  An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectScheduleId: ID!
  type: FinanceType!
  """
  The currency value to set.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  """
  value: Float!
  description: String
  """
  The ID of the finance category for this ProjectFinance.
  An unknown finance category `ID` causes `UserError` with type `NOT_FOUND`.
  """
  financeCategoryId: ID
}
input ProjectUpdateFieldsFieldsInput {
  booleanFields: [BooleanFieldUpdateInput!]
  businessGoalReferenceFields: [BusinessGoalReferenceFieldUpdateInput!]
  costTypeFields: [CostTypeFieldUpdateInput!]
  dateFields: [DateFieldUpdateInput!]
  decimalFields: [DecimalFieldUpdateInput!]
  integerFields: [IntegerFieldUpdateInput!]
  lookupFields: [LookupFieldUpdateInput!]
  obsReferenceFields: [ObsReferenceFieldUpdateInput!]
  resourceReferenceFields: [ResourceReferenceFieldUpdateInput!]
  stringFields: [StringFieldUpdateInput!]
  textFields: [TextFieldUpdateInput!]
  urlFields: [UrlFieldUpdateInput!]
}
input ProjectUpdateFieldsInput {
  """
  The ID of the scenario containing the project to modify.
  An unknown scenario `ID` causes `UserError` with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  The ID of the project to modify.
  An unknown project `ID` causes `UserError` with type `NOT_FOUND`.
  """
  projectId: ID!
  "Project fields to update"
  fields: ProjectUpdateFieldsFieldsInput!
}
input ProjectViewConfigurationFieldInput {
  id: ID
  fieldId: String!
  fieldType: ProjectViewConfigurationFieldType!
}
input ProjectViewConfigurationSectionInput {
  type: ProjectViewConfigurationSectionType!
  "The id of the section if the section already existed"
  id: ID
  "Name needs to be set for every section with type FIELD"
  name: String
  """
  The fields are only allowed for sections with type FIELD.
  The fields are saved in the order of the array and will be queried again in this order.
  """
  sortedFields: [ProjectViewConfigurationFieldInput!]
}
input ResourceAbsenceFilterInput {
  period: ResourceAbsencePeriodInput
}
input ResourceAbsencePeriodInput {
  start: ISO8601Date!
  end: ISO8601Date!
}
input ResourceAbsencesCreateInput {
  resourceId: ID!
  absences: [AbsenceCreateInput!]!
}
input ResourceAbsencesDeleteInput {
  resourceId: ID!
  absenceIds: [ID!]!
}
input ResourceAbsencesUpdateInput {
  resourceId: ID!
  absences: [ResourceAbsenceUpdateInput!]!
}
input ResourceAbsenceUpdateInput {
  id: ID!
  start: ISO8601Date!
  end: ISO8601Date!
  startType: AbsenceDayType! = FULL_DAY
  endType: AbsenceDayType! = FULL_DAY
}
input ResourceAllocationCreateInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown resource `ID` causes `UserError` with type `NOT_FOUND`."
  resourceId: ID!
  "An unknown project role `ID` causes `UserError` with type `NOT_FOUND`."
  projectRoleId: ID
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input ResourceAllocationCreateOrUpdateInput {
  projectScheduleId: ID!
  resourceId: ID!
  """
  Omitting the projectRole, will use resource's primaryRole for allocation project role.
  An explicit null, while resource has primary role is not allowed.
  """
  projectRoleId: ID
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
"A combination of IDs not matching any existing allocation causes `UserError` with type `NOT_FOUND`."
input ResourceAllocationDeleteInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown resource `ID` causes `UserError` with type `NOT_FOUND`."
  resourceId: ID!
  "An unknown project role `ID` causes `UserError` with type `NOT_FOUND`."
  projectRoleId: ID
}
input ResourceAllocationInput {
  """
  The ID of the resource to allocate.
  An unknown resource ID causes a user error with type `RESOURCE_NOT_FOUND`.
  """
  resourceId: ID!
  """
  The ID of the role to assign as the project role of the allocated resource.
  An unknown resource ID causes a user error with type `PROJECT_ROLE_NOT_FOUND`.
  Resources that have a primary role must be assigned a project role.
  Explicitely passing `null` for such a resource causes a user error with type `PROJECT_ROLE_REQUIRED`.
  Omit to use the allocated resource's primary role as project role without provoking a user error.
  """
  projectRoleId: ID
  """
  The segments of this allocation.
  Segment periods must not overlap but may have gaps. Those will be filled with 0.0 values.
  Segment values must not be negative. Values of segments scheduled completely outside the project period must be 0.0.
  Segments scheduled partially outside the project period will be cropped.
  An invalid segment period causes a user error with type `ALLOCATION_SEGMENT_END_BEFORE_START`.
  Overlapping segments cause a user error with type `ALLOCATION_SEGMENTS_OVERLAP`.
  A negative segments value cause a user error with type `ALLOCATION_SEGMENT_VALUE_NEGATIVE`.
  A segment with any other value than 0.0 scheduled completely outside the project period causes a user error with type `ALLOCATION_SEGMENT_NON_ZERO_VALUE_OUTSIDE_PROJECT_PERIOD`.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input ResourceAllocationSlicesFilterInput {
  """
  The ID of a scenario the requested roles are scheduled in.
  If the ID is unkown, an empty list will be returned.
  """
  scenarioId: ID!
  "The period to be used when querying aggregated allocation slices."
  period: SliceFilterPeriodInput!
}
"A combination of IDs not matching any existing resource allocation causes `UserError` with type `NOT_FOUND`."
input ResourceAllocationTransferToResourceInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown resource `ID` causes `UserError` with type `NOT_FOUND`."
  resourceId: ID!
  "An unknown project role `ID` causes `UserError` with type `NOT_FOUND`."
  projectRoleId: ID
  "An unknown target resource `ID` causes `UserError` with type `NOT_FOUND`."
  targetResourceId: ID!
  """
  Periods of the source allocation that should be transfered to the target.
  Periods overlapping or not intersecting the project period cause `UserError` with type `INVALID_PERIOD`.
  Omit to transfer the whole allocation to the target.
  """
  periods: [PeriodInput!]
}
"A combination of IDs not matching any existing resource allocation causes `UserError` with type `NOT_FOUND`."
input ResourceAllocationUnstaffToProjectRoleInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown resource `ID` causes `UserError` with type `NOT_FOUND`."
  resourceId: ID!
  "An unknown project role `ID` causes `UserError` with type `NOT_FOUND`."
  projectRoleId: ID!
  "To be unstaffed period. Periods must intersect project period and must not overlap. Otherwise it causes `UserError` with type `INVALID_PERIOD`."
  periods: [PeriodInput!]
}
input ResourceAllocationUpdateInput {
  projectScheduleId: ID!
  resourceId: ID!
  """
  Omitting the projectRole, will use resource's primaryRole for allocation project role.
  An explicit null, while resource has primary role is not allowed.
  """
  projectRoleId: ID
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input ResourceAvatarDeleteInput {
  resourceId: ID!
}
input ResourceAvatarUpdateInput {
  resourceId: ID!
  avatarDataBase64: String!
}
input ResourceCapacitySlicesFilterInput {
  "The period to be used when querying capacity slices."
  period: SliceFilterPeriodInput!
}
input ResourceChangeLogFilterInput {
  scenarioId: ID!
  roleId: ID
  resourceId: ID
}
input ResourceCreateInput {
  """
  User defined `ID` for the resource.
  Use this to reference the created resource with the one in your source system.
  A null externalId will cause the to be generated resource's id to be used as externalId, too.
  A blank externalId will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  An already existing externalId will cause `UserError` with type `DUPLICATE`.
  """
  externalId: ID
  """
  An optional user defined unique identifier of the resource.
  A string longer than 2048 characters causes `UserError` with type `RESOURCE_KEY_TOO_LONG`.
  A resourceKey already used by another resource causes `UserError` with type `RESOURCE_KEY_NOT_UNIQUE`.
  """
  resourceKey: ID
  """
  The first name of the resource.
  String longer than 1024 characters causes `UserError` with type `TOO_LONG`.
  """
  firstName: String
  """
  The last name of the resource.
  A blank last name will cause `UserError` with type `BLANK`.
  String longer than 1024 characters causes `UserError` with type `TOO_LONG`.
  """
  lastName: String!
  """
  The email address of the resource.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  emailAddress: String
  "The address information of the resource"
  postalAddress: PostalAddressInput
  "The employment period of the resource"
  employmentPeriod: EmploymentPeriodInput
  """
  The information whether the resource is your employee or an external resource.
  When omitted or sent with `null` value, it is set to false.
  """
  external: Boolean
  """
  The cost per hour (based on your system's currency) for this resource.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  Defining a value (including null) requires user permission `ACCESS_FINANCIAL_DATA`.
  """
  costPerHour: Float
  """
  The `ID` of an existing calendar that should be applied for this resource.
  See `calendars` query to get calendar `ID`s.
  Omitting this field or sending a `null` value will set the association to point to the default calendar.
  An unknown calendar `ID` will cause `UserError` with type `NOT_FOUND`
  """
  calendar: ID
  """
  The existing skills the new resource should be associated with by `ID`.
  See `skills` query to get skill `ID`s.
  Unknown skill `ID`s will cause `UserError` with type `NOT_FOUND`.
  """
  skills: [ID!]
  """
  The OBS units the new resource should be associated with by `ID`.
  See `obsUnitFindOrCreate` mutation to get OBS unit `ID`s.
  Note that a resource can not be associated with more than one OBS unit of the same OBS type.
  Unknown OBS unit `ID`s will cause `UserError` with type `NOT_FOUND`.
  Assigning more than one OBS unit of the same OBS type causes `UserError` with type `DUPLICATE`.
  """
  obsUnits: [ID!]
  """
  The `ID` of a existing role that should be assigned to this resource.
  See `roles` query to get role `ID`s.
  An unknown role `ID` will cause `UserError` with type `NOT_FOUND`
  """
  primaryRole: ID
  """
  The `ID` of an existing resource that manages this resource.
  An unknown resource `ID` will cause `UserError` with type `NOT_FOUND`
  """
  manager: ID
}
input ResourceDeleteInput {
  """
  The ID of the resource to delete.
  An unknown resource `ID` causes `UserError` with type `NOT_FOUND`.
  """
  resourceId: ID!
}
input ResourceEmploymentPeriodFilterInput {
  start: ISO8601Date!
  end: ISO8601Date!
}
input ResourceFilterInput {
  ids: [ID!]
  firstName: String
  lastName: String
  externalId: String
  """
  resourceKeys filter is exact case-insensitive match.
  Blank entries are ignored.
  """
  resourceKeys: [String!]
  emailAddresses: [String!]
  city: String
  country: String
  postalCode: String
  portfolioId: ID
  employmentPeriod: ResourceEmploymentPeriodFilterInput
  resourceStatus: [ResourceStatus!]
  primaryRoleIds: [ID]
  "Allows to return only the resources whose OBS types match the provided input."
  obsFilters: [ObsFilterInput!]
  external: Boolean
  "Allows to return only the resources that have ALL skills in the list."
  skillIds: [ID!]
  managerResourceIds: [ID]
  "Search resources by their name, resource key or primary role name using case-insensitive 'contains' match."
  searchTerm: String
}
input ResourceReferenceFieldInput {
  """
  The ID of the field to set a value for.
  An unknown resource reference field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the resource to set.
  An unknown resource ID causes an error with type `NOT_FOUND`.
  """
  resourceReferenceValue: ID
}
input ResourceReferenceFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown resource reference field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The ID of the resource reference field value to set.
  Unknown resource reference field value `ID` causes `UserError` with type `NOT_FOUND`.
  """
  resourceReferenceValue: ID
}
"""
Sorting criteria for resources
Omit to sort resources by default order which means ascending by their display name.
"""
input ResourceSortingInput {
  """
  The resource field to sort by.
  If sortField is OBS, then obsTypeId must be specified, DISPLAY_NAME is used as fallback if obsTypeId is missing.
  If sortField is NOT DISPLAY_NAME then DISPLAY_NAME ascending is automatically added as second sort criterion.
  """
  sortField: ResourceSortField!
  "obsTypeId must be specified if sortField is OBS. ObsTypeId is ignored for other sortField values."
  obsTypeId: ID
  direction: SortDirection!
}
input ResourceUpdateCalendarDeviationsInput {
  """
  The `ID` of the resource to update.
  See `resources` query to get resource `ID`s.
  Unknown `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  resourceId: ID!
  """
  A coherent list of new calendar deviations to be added for the specified resource.
  The list must consist of consecutive time periods represented by `CalendarDeviationInput` instances.
  A empty list will cause `UserError` with type `EMPTY`.
  A list with gaps will cause `UserError` with type `INCONSISTENT`.
  """
  calendarDeviations: [CalendarDeviationInput!]!
}
input ResourceUpdateInput {
  """
  The `ID` of the resource to update.
  See `resources` query to get resource `ID`s.
  Unknown `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  resourceId: ID!
  """
  The new externalId to set. Omit to leave unchanged.
  A blank or explicitly null externalId will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  An already existing externalId will cause `UserError` with type `DUPLICATE`.
  """
  externalId: String
  """
  An optional user defined unique identifier of the resource.
  A blank or explicitly null value will cause `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `RESOURCE_KEY_TOO_LONG`.
  A resourceKey already used by another resource causes `UserError` with type `RESOURCE_KEY_NOT_UNIQUE`.
  """
  resourceKey: ID
  """
  The new first name to set. Omit to leave unchanged.
  A `null` value will delete the existing first name value.
  String longer than 1024 characters causes `UserError` with type `TOO_LONG`.
  """
  firstName: String
  """
  The new last name to set. Omit to leave unchanged.
  A blank or explicitly null last name will cause `UserError` with type `BLANK`.
  String longer than 1024 characters causes `UserError` with type `TOO_LONG`.
  """
  lastName: String
  """
  The new email address to set. Omit to leave unchanged.
  A `null` value will delete the existing email address value.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  emailAddress: String
  "The new postal address to set. Omit to leave unchanged."
  postalAddress: PostalAddressInput
  "The new employment period to set. Omit to leave unchanged."
  employmentPeriod: EmploymentPeriodInput
  """
  The new external information to set. Omit to leave unchanged.
  When sent with `null` value, it is set to false.
  """
  external: Boolean
  """
  The new costPerHour to set. Omit to leave unchanged.
  A `null` value will delete the existing costPerHour value.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  Defining a value (including null) requires user permission `ACCESS_FINANCIAL_DATA`.
  """
  costPerHour: Float
  """
  The new skill associations for the resource. Omit to leave unchanged.
  See `skills` query to get skill `ID`s.
  A `null` value will delete all existing skill associations.
  All skills currently associated with the resource that are not in this list, will be disassociated.
  Unknown skill `ID`s will cause `UserError` with type `NOT_FOUND`.
  """
  skills: [ID!]
  """
  The changes for OBS unit associations to the resource. Omit to leave unchanged.
  See `obsUnitFindOrCreate` mutation to get OBS unit `ID`s.
  This input allows both to create new and to modify or delete existing OBS unit associaitons.
  Existing OBS unit associations, whose type is not in this list, will remain unchanged.
  """
  obsUnits: [ObsInput!]
  """
  The new manager to set. Omit to leave unchanged.
  A `null` value will delete the existing manager association.
  An unknown manager `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  manager: ID
  """
  The new primary role to set. Omit to leave unchanged.
  See `roles` query to get role `ID`s.
  A `null` value will delete the existing role association.
  An unknown role `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  primaryRole: ID
  """
  The new calendar for the resource to set. Omit to leave unchanged.
  See `calendars` query to get calendar `ID`s.
  A `null` value will reset the association to point to the default calendar.
  An unknown calendar `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  calendar: ID
}
input ResourceUpdateLinkedUserInput {
  resourceId: ID!
  linkedUser: ID
}
input RoleAllocationCreateInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown resource `ID` causes `UserError` with type `NOT_FOUND`."
  roleId: ID!
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input RoleAllocationCreateOrUpdateInput {
  projectScheduleId: ID!
  roleId: ID!
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
"A combination of IDs not matching any existing allocation causes `UserError` with type `NOT_FOUND`."
input RoleAllocationDeleteInput {
  "An unknown project schedule `ID` causes `UserError` with type `NOT_FOUND`."
  projectScheduleId: ID!
  "An unknown role `ID` causes `UserError` with type `NOT_FOUND`."
  roleId: ID!
}
input RoleAllocationInput {
  """
  The ID of the role to allocate.
  An unknown role ID causes a user error with type `ROLE_NOT_FOUND`.
  """
  roleId: ID!
  """
  The segments of this allocation.
  Segment periods must not overlap but may have gaps. Those will be filled with 0.0 values.
  Segment values must not be negative. Values of segments scheduled completely outside the project period must be 0.0.
  Segments scheduled partially outside the project period will be cropped.
  An invalid segment period causes a user error with type `ALLOCATION_SEGMENT_END_BEFORE_START`.
  Overlapping segments cause a user error with type `ALLOCATION_SEGMENTS_OVERLAP`.
  A negative segments value cause a user error with type `ALLOCATION_SEGMENT_VALUE_NEGATIVE`.
  A segment with any other value than 0.0 scheduled completely outside the project period causes a user error with type `ALLOCATION_SEGMENT_NON_ZERO_VALUE_OUTSIDE_PROJECT_PERIOD`.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input RoleAllocationSlicesFilterInput {
  """
  The ID of a scenario the requested roles are scheduled in.
  If the ID is unknown, an empty list will be returned.
  """
  scenarioId: ID!
  "The period to be used when querying allocation slices."
  period: SliceFilterPeriodInput!
}
input RoleAllocationUpdateInput {
  projectScheduleId: ID!
  roleId: ID!
  """
  Allocation values must not overlap, but may have gaps. Gaps are filled with 0 values.
  If a segment is (partially) outside the project period, it must have a 0 value.
  """
  allocationSegments: [AllocationSegmentInput!]!
}
input RoleCapacitiesFilterInput {
  roleId: ID
}
input RoleCapacityDeviationInput {
  "Omit to expand the start of this period to the minimum date supported by Meisterplan, 1970-1-1."
  start: ISO8601Date
  "Omit to expand the end of this period to the maximum date supported by Meisterplan, 2079-7-3."
  end: ISO8601Date
  "A positive or negative floating point value relative to the work time of the system's default calendar."
  additionalCapacity: Float!
  unit: RoleCapacityUnit!
}
input RoleCapacitySlicesFilterInput {
  """
  The ID of a scenario the requested roles are scheduled in.
  If the ID is unknown, an empty list will be returned.
  """
  scenarioId: ID!
  "The period to be used when querying capacity slices."
  period: SliceFilterPeriodInput!
  """
  The ID of a portfolio.
  If it is set, only the remaining capacity of those resources will be added to the capacity of the role that are members of role and the portfolio.
  If it is not set, the remaining capacity of all resources will be added to the capacity of the role that are members of the role.
  If the ID is unknown, no remaining capacity of any resource is added to the capacity of the role.
  """
  portfolioId: ID
}
input RoleCapacityUpdateDeviationsInput {
  """
  The ID of the role to update capacity deviations for.
  An unknown ID causes user error with type `NOT_FOUND`.
  """
  roleId: ID!
  """
  The ID of the scenario to update role capacity deviations in.
  An unknown ID causes user error with type `NOT_FOUND`.
  """
  scenarioId: ID!
  """
  A list of capacity deviations relative to the work time of the system's default calendar.
  Deviations must not intersect each other.
  Start dates must be before end dates.
  All dates must be within the closed range [1970-1-1, 2079-7-3].
  A violation of these constraints causes user error with type `INVALID`.
  """
  deviations: [RoleCapacityDeviationInput!]!
}
input RoleCreateInput {
  """
  User defined id for the role.
  Use this to reference the created role with the one in your source system.
  A null externalId will cause the to be generated role's id to be used as externalId, too.
  A blank externalId will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  A already existing externalId will cause `UserError` with type `DUPLICATE`.
  """
  externalId: String
  """
  The name of the role.
  A blank name will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  The `ID` of an existing resource that manages this role.
  An unknown resource `ID` will cause `UserError` with type `NOT_FOUND`
  """
  manager: ID
  """
  One of the possible `CostType` values for this role.
  If omitted or null will default to `OPEX`.
  """
  costType: CostType
  """
  The cost per hour (based on your system's currency) for this role.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  Defining a value (including null) requires user permission `ACCESS_FINANCIAL_DATA`.
  """
  costPerHour: Float
  """
  The OBS units the new role should be associated with by `ID`.
  See `obsUnitFindOrCreate` mutation to get OBS unit `ID`s.
  Note that a role can not be associated with more than one OBS unit of the same OBS type.
  Unknown OBS unit `ID`s will cause `UserError` with type `NOT_FOUND`.
  Assigning more than one OBS unit of the same OBS type causes `UserError` with type `DUPLICATE`.
  """
  obsUnits: [ID!]
}
input RoleDeleteInput {
  """
  The ID of the role to delete.
  An unknown role `ID` causes `UserError` with type `NOT_FOUND`.
  """
  roleId: ID!
}
input RoleFilterInput {
  ids: [ID!]
  externalId: String
  "Allows to return only the roles whose names exactly match the provided input."
  names: [String!]
  "Search roles by their name using case-insensitive 'contains' match."
  searchTerm: String
  portfolioId: ID
  "Allows to return only the roles whose OBS types match the provided input."
  obsFilters: [ObsFilterInput!]
  managerResourceIds: [ID]
}
"""
Sorting criteria for roles
Omit to sort roles by default order which means ascending by their display name.
"""
input RoleSortingInput {
  """
  The role field to sort by.
  If sortField is OBS, then obsTypeId must be specified, ROLE_NAME is used as fallback if obsTypeId is missing.
  If sortField is NOT ROLE_NAME then ROLE_NAME ascending is automatically added as second sort criterion.
  """
  sortField: RoleSortField!
  "obsTypeId must be specified if sortField is OBS. ObsTypeId is ignored for other sortField values."
  obsTypeId: ID
  direction: SortDirection!
}
input RoleUpdateInput {
  """
  The `ID` of the role to update.
  See `role` query to get role `ID`s.
  Unknown `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  roleId: ID!
  """
  The new externalId to set. Omit to leave unchanged.
  A blank or explicitly null externalId will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  An already existing externalId will cause `UserError` with type `DUPLICATE`.
  """
  externalId: String
  """
  The new name to set. Omit to leave unchanged.
  A blank or explicitly null name will cause `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String
  """
  The new `CostType` to set. Omit to leave unchanged.
  A `null` value will cause a reset to the default value `OPEX`.
  """
  costType: CostType
  """
  The new manager to set. Omit to leave unchanged.
  A `null` value will delete the existing manager association.
  An unknown manager `ID` will cause `UserError` with type `NOT_FOUND`.
  """
  manager: ID
  """
  The new costPerHour to set. Omit to leave unchanged.
  A `null` value will delete the existing costPerHour value.
  A negative value will cause `UserError` with type `NEGATIVE_NUMBER`.
  Defining a value (including null) requires user permission `ACCESS_FINANCIAL_DATA`.
  """
  costPerHour: Float
  """
  The changes for OBS unit associations to the role. Omit to leave unchanged.
  See `obsUnitFindOrCreate` mutation to get OBS unit `ID`s.
  This input allows both to create new and to modify or delete existing OBS unit associaitons.
  Existing OBS unit associations, whose type is not in this list, will remain unchanged.
  """
  obsUnits: [ObsInput!]
}
input RollingDateRangeConfigurationInput {
  monthsBeforeCurrent: Int!
  monthsAfterCurrent: Int!
}
input ScenarioAllocationFilterInput {
  "Filters allocations to those associated with projects, resources or roles in the given portfolio."
  portfolioId: ID
  "Filters allocations to those at least partly scheduled within the given period."
  period: AllocationPeriodInput!
}
input ScenarioCopyInput {
  "Unknown scenario `ID` will cause `UserError` with type `NOT_FOUND`."
  sourceScenarioId: ID!
  """
  Blank scenario name causes `UserError` with type `BLANK`.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  name: String!
  """
  A list of user IDs to assign to the scenario.
  Omit to use the source's assignees.
  The requesting user is always added as a (or the only) assignee.
  An unknown user ID causes a user error with type `USER_NOT_FOUND`.
  """
  assignedUserIds: [String!]
  """
  A flag indicating whether the scenario is archived or not.
  Omitting will default to false.
  """
  archived: Boolean
}
input ScenarioDeleteInput {
  """
  The ID of the scenario to delete.
  An unknown scenario ID causes a user error with type `SCENARIO_NOT_FOUND`.
  """
  id: ID!
}
input ScenarioFilterInput {
  archived: Boolean
  ids: [ID!]
}
input ScenarioPrioritiesRankByProjectScoreInput {
  """
  The ID of the scenario to modify.
  An unknown scenario ID causes a user error with type `SCENARIO_NOT_FOUND`.
  """
  scenarioId: ID!
  """
  The ID of a portfolio to filter by.
  If given, projects not in the portfolio and non-empty programs not containing at least one project in the portfolio keep their current priority,
  while all projects in the portfolio and all programs containing at least one project in the portfolio are re-prioritized according to their project score.
  With a portfolio filter given, only portfolio members are considered when calculating the project score of a program schedule.
  An unknown portfolio ID causes a user error with type `PORTFOLIO_NOT_FOUND`.
  """
  portfolioId: ID
  """
  The ID of a project schedule or program schedule in the scenario to use as a reference for downstream ranking.
  If given, projects and programs with a higher priority than the downstream reference keep their current priority,
  while the given downstream reference and all projects and programs with a lower priority are re-prioritized according to their project score.
  Specifying a project within a program as the downstream reference has the same effect as specifying the program itself.
  An unknown ID causes a user error with type `DOWNSTREAM_REFERENCE_NOT_FOUND`.
  """
  downstreamReferenceId: ID
}
input ScenarioSubmitToPlanOfRecordInput {
  """
  The ID of the scenario to submit.
  An unknown scenario ID causes a user error with type `SOURCE_SCENARIO_NOT_FOUND`.
  """
  sourceScenarioId: ID!
}
input ScenarioUpdateInput {
  """
  The ID of the scenario to update.
  An unknown scenario ID causes a user error with type `SCENARIO_NOT_FOUND`.
  """
  id: ID!
  """
  A new name for the scenario.
  Omit to keep the current name.
  An empty or blank name causes a user error with type `NAME_BLANK`.
  A name longer than 2048 characters causes a user error with type `NAME_TOO_LONG`.
  """
  name: String
  """
  A list of user IDs to assign to the scenario.
  Omit to keep the current assignees.
  An unknown user ID causes a user error with type `USER_NOT_FOUND`.
  """
  assignedUserIds: [String!]
  """
  A flag indicating whether the scenario is archived or not.
  `true` to archive the scenario.
  `false`to reinstate the scenario.
  Omit to keep the current value.
  """
  archived: Boolean
}
input SkillCreateInput {
  """
  The name of the skill.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  A name already given to another existing skill causes `UserError` with type `DUPLICATE`.
  """
  name: String!
}
input SkillDeleteInput {
  """
  The `ID` of the skill to delete.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
}
input SkillUpdateNameInput {
  """
  The `ID` of the skill to update.
  An unknown ID causes `UserError` with type `NOT_FOUND`.
  """
  id: ID!
  """
  The new name of the skill.
  A blank name causes `UserError` with type `BLANK`.
  A string longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  A name already given to another existing skill causes `UserError` with type `DUPLICATE`.
  """
  name: String!
}
"""
A period to be used when querying slices.
It is only considered valid if `start` is before `finish`.
Possible input errors:
- too many slices
- end before start
"""
input SliceFilterPeriodInput {
  "A date that specify a point in time in ISO8601, e.g. 2020-06-04"
  start: ISO8601Date!
  """
  A date that specify a point in time in ISO8601, e.g. 2020-06-04
  The end date is inclusive.
  """
  end: ISO8601Date!
}
input StringFieldInput {
  """
  The ID of the field to set a value for.
  An unknown string field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The string value to set.
  A string longer than 2048 characters causes an error with type `TOO_LONG`.
  """
  stringValue: String
}
input StringFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown string field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The string value to set.
  String longer than 2048 characters causes `UserError` with type `TOO_LONG`.
  """
  stringValue: String
}
input TextFieldInput {
  """
  The ID of the field to set a value for.
  An unknown text field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The text value to set.
  A string longer than 32000 characters causes an error with type `TOO_LONG`.
  """
  textValue: String
}
input TextFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown text field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The text value to set.
  String longer than 32000 characters causes `UserError` with type `TOO_LONG`.
  """
  textValue: String
}
input TigerBlogPostFilter {
  blogPostIds: [ID!]!
}
input TigerBlogPostPublishInput {
  blogPostId: ID!
  text: String!
}
input UpdateAllocationModeInput {
  allocationMode: AllocationMode!
}
input UpdateWorkloadUnitInput {
  workloadUnit: WorkloadUnit!
}
input UrlFieldInput {
  """
  The ID of the field to set a value for.
  An unknown url field ID causes an error with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The url value to set.
  A string longer than 4096 characters causes an error with type `TOO_LONG`.
  """
  urlValue: String
}
input UrlFieldUpdateInput {
  """
  The ID of the field to set a value for.
  Unknown url field `ID` causes `UserError` with type `NOT_FOUND`.
  """
  definition: ID!
  """
  The url value to set.
  String longer than 4096 characters causes `UserError` with type `TOO_LONG`.
  """
  urlValue: String
}
input UserAvatarDeleteInput {
  _: Boolean
}
input UserAvatarUpdateInput {
  avatarDataBase64: String!
}
input UserChangeActivationStateInput {
  id: ID!
  activationState: UserActivationState!
}
input UserCreateInput {
  userName: String!
  email: String!
  firstName: String
  lastName: String
  passwordNeverExpires: Boolean!
  sendInvitationMail: Boolean!
  linkedResource: ID
  userGroups: [ID!]!
  inviteSource: InviteSource
}
input UserFilterInput {
  ids: [ID!]
  linkedResourceIds: [ID!]
  activationState: UserActivationState
  userName: String
}
input UserGroupCreateInput {
  name: String!
  permissions: UserGroupPermissionsInput
  projectFields: UserGroupProjectFieldsInput
  users: [ID!]!
}
input UserGroupDeleteInput {
  id: ID!
}
input UserGroupFilterInput {
  ids: [ID!]
  name: String
}
input UserGroupPermissionsInput {
  modifyProjectsAndPrograms: UserGroupPermissionScope!
  editPlanOfRecord: Boolean!
  replacePlanOfRecordWithScenario: Boolean!
  addProjectsAndPrograms: Boolean!
  deleteProjectsAndPrograms: Boolean!
  changeProjectRank: Boolean!
  sortProjectsByProjectScore: Boolean!
  changeProjectSchedule: Boolean!
  autoScheduleMultipleProjects: Boolean!
  addChangeAndDeleteFinancialEvents: Boolean!
  addChangeAndDeleteAllocations: Boolean!
  addChangeAndDeleteMilestones: Boolean!
  manageReports: UserGroupPermissionScope!
  managePortfolios: UserGroupPermissionScope!
  manageScenarios: UserGroupPermissionScope!
  manageResourcePoolAndAbsences: Boolean!
  manageProjectFields: Boolean!
  manageUsersAndUserGroups: Boolean!
  manageSubscriptions: Boolean!
  useMeisterplanApiAndExternalApplications: Boolean!
  importData: Boolean!
  exportData: Boolean!
  configureAndUseDataSources: Boolean!
  accessChangeLog: Boolean!
  configureQuickFilters: Boolean!
  accessActualTimeWorked: ActualTimeWorkedScope!
  accessFinancialData: Boolean!
  manageJiraLinks: Boolean!
  manageCustomViews: CustomViewsScope!
  manageSandbox: Boolean!
}
input UserGroupProjectFieldsInput {
  readOnlyIds: [ID!]!
  writeAndReadIds: [ID!]!
}
input UserGroupUpdateInput {
  id: ID!
  name: String
  permissions: UserGroupPermissionsInput
  projectFields: UserGroupProjectFieldsInput
  users: [ID!]
}
input UserReinviteInput {
  id: ID!
}
input UserResendVerificationMailInput {
  _: Boolean
}
input UserUpdateInput {
  id: ID!
  userName: String!
  email: String!
  firstName: String
  lastName: String
  passwordNeverExpires: Boolean!
  linkedResource: ID
  userGroups: [ID!]!
}
input UserUpdateMyFirstNameInput {
  firstName: String
}
input UserUpdateMyLastNameInput {
  lastName: String
}
input UserUpdateMyLocaleInput {
  locale: String!
}
input ViewConfigActivateInput {
  viewKey: String!
  id: ID!
}
input ViewConfigCreateInput {
  viewKey: ID!
  jsonValue: String
  name: String!
  permissions: ViewConfigPermissionsInput!
}
input ViewConfigDeleteInput {
  viewKey: String!
  id: ID!
}
input ViewConfigMetaDataUpdateInput {
  viewKey: String!
  id: ID!
  name: String!
  permissions: ViewConfigPermissionsInput!
}
input ViewConfigPermissionsInput {
  users: [ID!]!
  userGroups: [ID!]!
}
input ViewConfigValueUpdateInput {
  viewKey: String!
  id: ID!
  jsonValue: String!
}
input WebhookCreateInput {
  name: String!
  callbackUrl: String!
  eventTypes: [WebhookEventType!]!
  scenarioId: ID!
  projectId: ID
  secret: String
}
input WebhookDeleteInput {
  id: ID!
}
input WebhookUpdateStatusInput {
  id: ID!
  status: WebhookUpdateStatus!
}
directive @apollo_studio_metadata(buildId: String, checkId: String, launchId: String) on SCHEMA
"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

